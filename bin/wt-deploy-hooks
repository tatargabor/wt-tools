#!/usr/bin/env bash
# wt-deploy-hooks - Deploy Claude Code hooks to a target directory
#
# Usage: wt-deploy-hooks [--quiet] [--no-memory] <target-dir>
#
# Deploys 5 hook events to <target-dir>/.claude/settings.json:
#   - SessionStart: memory warmstart (L1)
#   - UserPromptSubmit: skill detection + memory recall (L2)
#   - PreToolUse[Bash]: hot-topic memory recall (L3)
#   - PostToolUseFailure[Bash]: error recovery recall (L4)
#   - Stop: stop hook + memory save (L5)
#
# Use --no-memory to deploy only base hooks (for benchmark baseline).
# Idempotent: skips if all hooks are already present.
# Upgrades existing configs: adds new hooks while preserving existing entries.
# Creates backup before modifying existing settings.

set -e

QUIET=false
NO_MEMORY=false
TARGET_DIR=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --quiet|-q)
            QUIET=true
            shift
            ;;
        --no-memory)
            NO_MEMORY=true
            shift
            ;;
        *)
            TARGET_DIR="$1"
            shift
            ;;
    esac
done

if [[ -z "$TARGET_DIR" ]]; then
    echo "Usage: wt-deploy-hooks [--quiet] [--no-memory] <target-dir>" >&2
    exit 1
fi

if [[ ! -d "$TARGET_DIR" ]]; then
    echo "Error: directory does not exist: $TARGET_DIR" >&2
    exit 1
fi

_info() { $QUIET || echo "$@"; }
_success() { $QUIET || echo "  âœ” $*"; }

settings_file="$TARGET_DIR/.claude/settings.json"

mkdir -p "$TARGET_DIR/.claude"

# Full hook config (with all 5 memory layers)
hook_json=$(cat << 'HOOKJSON'
{
  "hooks": {
    "SessionStart": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "wt-hook-memory-warmstart",
            "timeout": 10
          }
        ]
      }
    ],
    "UserPromptSubmit": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "wt-hook-skill",
            "timeout": 5
          },
          {
            "type": "command",
            "command": "wt-hook-memory-recall",
            "timeout": 15
          }
        ]
      }
    ],
    "PreToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "wt-hook-memory-pretool",
            "timeout": 5
          }
        ]
      }
    ],
    "PostToolUseFailure": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "wt-hook-memory-posttool",
            "timeout": 5
          }
        ]
      }
    ],
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "wt-hook-stop",
            "timeout": 5
          },
          {
            "type": "command",
            "command": "wt-hook-memory-save",
            "timeout": 30
          }
        ]
      }
    ]
  }
}
HOOKJSON
)

# Base-only hook config (no memory hooks)
hook_json_no_memory=$(cat << 'HOOKJSON'
{
  "hooks": {
    "UserPromptSubmit": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "wt-hook-skill",
            "timeout": 5
          }
        ]
      }
    ],
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "wt-hook-stop",
            "timeout": 5
          }
        ]
      }
    ]
  }
}
HOOKJSON
)

# Select which config to deploy
if $NO_MEMORY; then
    deploy_json="$hook_json_no_memory"
else
    deploy_json="$hook_json"
fi

if [[ -f "$settings_file" ]]; then
    # Check what hooks are already configured
    has_base=false
    has_memory_old=false
    has_memory_new=false

    if jq -e '.hooks.Stop[0].hooks[] | select(.command == "wt-hook-stop")' "$settings_file" &>/dev/null \
        && jq -e '.hooks.UserPromptSubmit[0].hooks[] | select(.command == "wt-hook-skill")' "$settings_file" &>/dev/null; then
        has_base=true
    fi

    # Old memory hooks (L2 + L5)
    if jq -e '.hooks.Stop[0].hooks[] | select(.command == "wt-hook-memory-save")' "$settings_file" &>/dev/null \
        && jq -e '.hooks.UserPromptSubmit[0].hooks[] | select(.command == "wt-hook-memory-recall")' "$settings_file" &>/dev/null; then
        has_memory_old=true
    fi

    # New memory hooks (L1 + L3 + L4)
    if jq -e '.hooks.SessionStart[0].hooks[] | select(.command == "wt-hook-memory-warmstart")' "$settings_file" &>/dev/null \
        && jq -e '.hooks.PreToolUse[] | select(.hooks[] | .command == "wt-hook-memory-pretool")' "$settings_file" &>/dev/null \
        && jq -e '.hooks.PostToolUseFailure[] | select(.hooks[] | .command == "wt-hook-memory-posttool")' "$settings_file" &>/dev/null; then
        has_memory_new=true
    fi

    # Already complete?
    if $has_base; then
        if $NO_MEMORY || ($has_memory_old && $has_memory_new); then
            return 0 2>/dev/null || exit 0
        fi
    fi

    # Backup before modification
    cp "$settings_file" "$settings_file.bak"

    if $has_base && $has_memory_old && ! $has_memory_new && ! $NO_MEMORY; then
        # Upgrade path: old 2-hook memory exists, add new 3 hooks (L1, L3, L4)
        jq '
          .hooks.SessionStart = [{"matcher": "", "hooks": [{"type": "command", "command": "wt-hook-memory-warmstart", "timeout": 10}]}]
          | .hooks.PreToolUse = ((.hooks.PreToolUse // []) + [{"matcher": "Bash", "hooks": [{"type": "command", "command": "wt-hook-memory-pretool", "timeout": 5}]}])
          | .hooks.PostToolUseFailure = [{"matcher": "Bash", "hooks": [{"type": "command", "command": "wt-hook-memory-posttool", "timeout": 5}]}]
        ' "$settings_file" > "$settings_file.tmp" && mv "$settings_file.tmp" "$settings_file"
        _success "Updated: $settings_file (added L1/L3/L4 memory hooks)"

    elif $has_base && ! $has_memory_old && ! $NO_MEMORY; then
        # Upgrade path: base hooks exist, add ALL memory hooks
        jq '
          .hooks.SessionStart = [{"matcher": "", "hooks": [{"type": "command", "command": "wt-hook-memory-warmstart", "timeout": 10}]}]
          | .hooks.UserPromptSubmit[0].hooks += [{"type": "command", "command": "wt-hook-memory-recall", "timeout": 15}]
          | .hooks.PreToolUse = ((.hooks.PreToolUse // []) + [{"matcher": "Bash", "hooks": [{"type": "command", "command": "wt-hook-memory-pretool", "timeout": 5}]}])
          | .hooks.PostToolUseFailure = [{"matcher": "Bash", "hooks": [{"type": "command", "command": "wt-hook-memory-posttool", "timeout": 5}]}]
          | .hooks.Stop[0].hooks += [{"type": "command", "command": "wt-hook-memory-save", "timeout": 30}]
        ' "$settings_file" > "$settings_file.tmp" && mv "$settings_file.tmp" "$settings_file"
        _success "Updated: $settings_file (added all memory hooks)"
    else
        # Fresh merge: deploy full config
        jq --argjson hooks "$(echo "$deploy_json" | jq '.hooks')" \
            '. * {"hooks": (.hooks // {} | . * $hooks)}' \
            "$settings_file" > "$settings_file.tmp" && mv "$settings_file.tmp" "$settings_file"
        _success "Updated: $settings_file (added hooks)"
    fi
else
    echo "$deploy_json" | jq '.' > "$settings_file"
    _success "Created: $settings_file (hooks)"
fi
