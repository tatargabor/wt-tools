#!/usr/bin/env bash
# wt-merge - Merge a worktree branch to target branch

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/wt-common.sh"

usage() {
    cat <<EOF
Usage: wt-merge <change-id> [options]

Merge a worktree's branch into a target branch.

Arguments:
  change-id               The change identifier

Options:
  -p, --project <name>    Use specific project (default: auto-detect)
  --to <branch>           Target branch (default: auto-detect main/master)
  --squash                Squash commits into one
  --no-delete             Keep source branch after merge
  --no-push               Don't push after merge (default: push)
  -h, --help              Show this help

Examples:
  wt-merge add-user-auth
  wt-merge add-user-auth --to develop
  wt-merge add-user-auth --squash
EOF
}

# Find the default branch (main or master)
find_default_branch() {
    local project_path="$1"

    if git -C "$project_path" show-ref --verify --quiet refs/heads/main 2>/dev/null; then
        echo "main"
    elif git -C "$project_path" show-ref --verify --quiet refs/heads/master 2>/dev/null; then
        echo "master"
    else
        echo ""
    fi
}

main() {
    local change_id=""
    local project_name=""
    local target_branch=""
    local squash=false
    local delete_branch=true
    local push_after=true

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--project)
                project_name="$2"
                shift 2
                ;;
            --to)
                target_branch="$2"
                shift 2
                ;;
            --squash)
                squash=true
                shift
                ;;
            --no-delete)
                delete_branch=false
                shift
                ;;
            --no-push)
                push_after=false
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -*)
                error "Unknown option: $1"
                usage
                exit 1
                ;;
            *)
                if [[ -z "$change_id" ]]; then
                    change_id="$1"
                else
                    error "Unexpected argument: $1"
                    usage
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$change_id" ]]; then
        error "Change ID required"
        usage
        exit 1
    fi

    # Resolve project
    local resolved_project
    resolved_project=$(resolve_project "$project_name") || exit 1

    local project_path
    project_path=$(get_project_path "$resolved_project")

    # Find existing worktree
    local wt_path
    wt_path=$(find_existing_worktree "$project_path" "$change_id")

    if [[ -z "$wt_path" || ! -d "$wt_path" ]]; then
        error "Worktree not found for: $change_id"
        exit 1
    fi

    # Get branch name from worktree
    local source_branch
    source_branch=$(git -C "$wt_path" rev-parse --abbrev-ref HEAD 2>/dev/null)

    if [[ -z "$source_branch" ]]; then
        error "Could not determine branch for worktree"
        exit 1
    fi

    # Determine target branch
    if [[ -z "$target_branch" ]]; then
        target_branch=$(find_default_branch "$project_path")
        if [[ -z "$target_branch" ]]; then
            error "Could not find default branch (main/master). Use --to <branch>"
            exit 1
        fi
    fi

    # Verify target branch exists
    if ! git -C "$project_path" show-ref --verify --quiet "refs/heads/$target_branch" 2>/dev/null; then
        error "Target branch '$target_branch' does not exist"
        exit 1
    fi

    # Check for uncommitted changes in worktree
    local changes
    changes=$(git -C "$wt_path" status --porcelain 2>/dev/null | grep -v "^?? \.zed/" | grep -v "^?? " || true)
    if [[ -n "$changes" ]]; then
        error "Worktree has uncommitted changes. Commit or stash them first."
        echo ""
        echo "$changes"
        exit 1
    fi

    # Check for uncommitted changes in main repo (needed for checkout)
    local main_changes
    main_changes=$(git -C "$project_path" status --porcelain 2>/dev/null | grep -v "^?? " || true)
    if [[ -n "$main_changes" ]]; then
        error "Main repo has uncommitted changes. Commit or stash them first."
        echo ""
        echo "$main_changes"
        echo ""
        echo "Run: cd $project_path && git stash"
        exit 1
    fi

    info "Merging '$source_branch' into '$target_branch'..."
    echo "  Project: $resolved_project"
    echo "  Source: $source_branch"
    echo "  Target: $target_branch"
    if $squash; then
        echo "  Mode: squash"
    fi

    # Go to project root and checkout target branch
    cd "$project_path" || exit 1

    # Fetch latest
    git fetch origin "$target_branch" 2>/dev/null || true

    # Checkout target branch
    git checkout "$target_branch"
    if [[ $? -ne 0 ]]; then
        error "Failed to checkout '$target_branch'"
        exit 1
    fi

    # Pull latest
    git pull origin "$target_branch" 2>/dev/null || true

    # Merge
    local merge_result
    if $squash; then
        git merge --squash "$source_branch"
        merge_result=$?
        if [[ $merge_result -eq 0 ]]; then
            git commit -m "Squashed merge of '$source_branch'"
            merge_result=$?
        fi
    else
        git merge "$source_branch" -m "Merge '$source_branch' into '$target_branch'"
        merge_result=$?
    fi

    if [[ $merge_result -ne 0 ]]; then
        error "Merge failed! Resolve conflicts manually."
        echo ""
        echo "After resolving:"
        echo "  git add ."
        echo "  git commit"
        echo "  wt-close $change_id"
        exit 1
    fi

    success "Merge completed successfully"

    # Push merged target branch to origin
    if $push_after; then
        info "Pushing '$target_branch' to origin..."
        if git push origin "$target_branch"; then
            success "Pushed to origin/$target_branch"
        else
            warn "Failed to push to origin. Push manually: git push origin $target_branch"
        fi
    fi

    # Delete source branch if requested
    if $delete_branch; then
        echo ""
        info "Deleting source branch '$source_branch'..."
        git branch -d "$source_branch" 2>/dev/null
        if [[ $? -eq 0 ]]; then
            success "Branch '$source_branch' deleted"
        else
            # Force delete if not fully merged (squash case)
            git branch -D "$source_branch" 2>/dev/null
            if [[ $? -eq 0 ]]; then
                success "Branch '$source_branch' deleted (force)"
            else
                warn "Could not delete branch (still checked out in worktree)"
                echo "  Branch will be deleted when you run: wt-close $change_id"
            fi
        fi
    fi

    echo ""
    success "Done! Close the worktree with:"
    echo "  wt-close $change_id"
}

main "$@"
