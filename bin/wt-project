#!/usr/bin/env bash
# wt-project - Manage project registry for wt-tools

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/wt-common.sh"

# Resolve wt-tools repo root (follow symlinks to find the real bin dir)
_wt_project_script="${BASH_SOURCE[0]}"
while [[ -L "$_wt_project_script" ]]; do
    _link=$(readlink "$_wt_project_script")
    if [[ "$_link" == /* ]]; then _wt_project_script="$_link"; else _wt_project_script="$(dirname "$_wt_project_script")/$_link"; fi
done
WT_TOOLS_ROOT="$(cd "$(dirname "$_wt_project_script")/.." && pwd)"

# Deploy wt-tools hooks, commands, and skills to a project's .claude/ directory.
# Usage: deploy_wt_tools <project-path> [<extra-mcp-path> ...]
# extra-mcp-path: additional paths to register MCP for (e.g. current worktree)
deploy_wt_tools() {
    local project_path="$1"
    shift
    local claude_dir="$project_path/.claude"

    # 1. Deploy hooks via wt-deploy-hooks
    "$SCRIPT_DIR/wt-deploy-hooks" --quiet "$project_path"
    success "  Deployed hooks to .claude/settings.json"

    # 2. Deploy /wt:* commands
    local src_commands="$WT_TOOLS_ROOT/.claude/commands/wt"
    local dst_commands="$claude_dir/commands/wt"
    if [[ -d "$src_commands" ]]; then
        mkdir -p "$dst_commands"
        if [[ "$(realpath "$src_commands")" != "$(realpath "$dst_commands")" ]]; then
            cp -r "$src_commands"/* "$dst_commands/"
        fi
        local cmd_count
        cmd_count=$(ls -1 "$src_commands"/*.md 2>/dev/null | wc -l)
        success "  Deployed $cmd_count command(s) to .claude/commands/wt/"
    else
        warn "  Source commands not found: $src_commands"
    fi

    # 3. Deploy wt skills
    local src_skills="$WT_TOOLS_ROOT/.claude/skills/wt"
    local dst_skills="$claude_dir/skills/wt"
    if [[ -d "$src_skills" ]]; then
        mkdir -p "$dst_skills"
        if [[ "$(realpath "$src_skills")" != "$(realpath "$dst_skills")" ]]; then
            cp -r "$src_skills"/* "$dst_skills/"
        fi
        success "  Deployed skills to .claude/skills/wt/"
    else
        warn "  Source skills not found: $src_skills"
    fi

    # 4. Remove deprecated inline memory hooks from OpenSpec skill/command files
    if command -v wt-memory-hooks &>/dev/null; then
        (cd "$project_path" && wt-memory-hooks remove --quiet) 2>/dev/null || true
    fi

    # 4b. Clean up deprecated memory references
    _cleanup_deprecated_memory_refs "$project_path"

    # 5. Ensure CLAUDE.md has the Persistent Memory section
    local claude_md="$project_path/CLAUDE.md"
    local memory_marker="## Persistent Memory"
    if [[ ! -f "$claude_md" ]] || ! grep -q "$memory_marker" "$claude_md" 2>/dev/null; then
        local snippet
        snippet=$(cat << 'MEMORY_SNIPPET'

## Persistent Memory

This project uses persistent memory (shodh-memory) across sessions. Memory context is automatically injected into `<system-reminder>` tags in your conversation — **you MUST read and use this context**.

**IMPORTANT: On EVERY prompt, check for injected memory context (system-reminder tags labeled "PROJECT MEMORY", "PROJECT CONTEXT", or "MEMORY: Context for this command"). When present, acknowledge and use it BEFORE doing independent research. If a memory directly answers the user's question or provides a known fix, cite it explicitly (e.g., "From memory: ...") instead of re-investigating from scratch. This applies to every turn, not just the first one.**

**How it works:**
- Session start → relevant memories loaded as system-reminder
- Every prompt → topic-based recall injected as system-reminder
- Every tool use → relevant past experience injected as system-reminder
- Tool errors → past fixes surfaced automatically
- Session end → insights extracted and saved

**Active (MCP tools):** You also have MCP memory tools available (`remember`, `recall`, `proactive_context`, etc.) for deeper memory interactions when automatic context isn't enough.

**Emphasis (use sparingly):**
- `echo "<insight>" | wt-memory remember --type <Decision|Learning|Context> --tags source:user,<topic>` — mark something as HIGH IMPORTANCE
- `wt-memory forget <id>` — suppress or correct a wrong memory
- Most things are remembered automatically. Only use `remember` for emphasis.
MEMORY_SNIPPET
)
        if [[ -f "$claude_md" ]]; then
            # Append to existing CLAUDE.md
            echo "$snippet" >> "$claude_md"
        else
            # Create new CLAUDE.md (strip leading newline)
            echo "${snippet#$'\n'}" > "$claude_md"
        fi
        success "  Added Persistent Memory section to CLAUDE.md"
    fi

    # 6. Register wt-memory MCP server for the project path (and any extra paths, e.g. worktree)
    _register_mcp_server "$project_path" "$@"
}

# Register the wt-memory MCP server scoped to one or more project paths.
# Usage: _register_mcp_server <path> [<extra-path> ...]
# claude mcp add uses PWD as the scope key, so we cd into each path before registering.
_register_mcp_server() {
    if ! command -v claude &>/dev/null; then
        return 0  # claude CLI not available, skip
    fi
    local mcp_server="$WT_TOOLS_ROOT/bin/wt-memory-mcp-server.py"
    [[ -f "$mcp_server" ]] || return 0
    for reg_path in "$@"; do
        [[ -d "$reg_path" ]] || continue
        (cd "$reg_path" && claude mcp remove wt-memory 2>/dev/null; claude mcp add wt-memory -- "$mcp_server" 2>/dev/null) || true
    done
    success "  Registered wt-memory MCP server"
}

# Clean up deprecated memory references from skill/command files
_cleanup_deprecated_memory_refs() {
    local project_path="$1"

    # Remove <!-- wt-memory hooks --> blocks from SKILL.md files
    if [[ -d "$project_path/.claude/skills" ]]; then
        find "$project_path/.claude/skills" -name "SKILL.md" -type f 2>/dev/null | while read -r f; do
            if grep -q '<!-- wt-memory hooks' "$f" 2>/dev/null; then
                python3 -c "
import re, sys
with open(sys.argv[1]) as f:
    content = f.read()
# Remove all wt-memory hooks blocks (including variants like hooks-midflow, hooks-remember, etc.)
cleaned = re.sub(r'<!--\s*wt-memory hooks[^>]*-->.*?<!--\s*/wt-memory hooks[^>]*-->\s*\n?', '', content, flags=re.DOTALL)
if cleaned != content:
    with open(sys.argv[1], 'w') as f:
        f.write(cleaned)
" "$f" 2>/dev/null || true
            fi
        done
    fi

    # Remove manual wt-memory recall/remember instructions from command .md files
    # Exclude commands/wt/ — those are wt-tools' own commands that legitimately use wt-memory
    if [[ -d "$project_path/.claude/commands" ]]; then
        find "$project_path/.claude/commands" -name "*.md" -type f 2>/dev/null | while read -r f; do
            # Skip wt-tools command files (commands/wt/*.md) — they use wt-memory intentionally
            [[ "$f" == */commands/wt/*.md ]] && continue
            if grep -qE 'wt-memory (recall|remember)' "$f" 2>/dev/null; then
                python3 -c "
import re, sys
with open(sys.argv[1]) as f:
    content = f.read()
# Remove lines containing wt-memory recall or wt-memory remember instructions
lines = content.split('\n')
cleaned_lines = [l for l in lines if not re.search(r'wt-memory\s+(recall|remember)', l)]
cleaned = '\n'.join(cleaned_lines)
if cleaned != content:
    with open(sys.argv[1], 'w') as f:
        f.write(cleaned)
" "$f" 2>/dev/null || true
            fi
        done
    fi

    # Delete .claude/hot-topics.json if it exists
    if [[ -f "$project_path/.claude/hot-topics.json" ]]; then
        rm -f "$project_path/.claude/hot-topics.json"
    fi
}

usage() {
    cat <<EOF
Usage: wt-project <command> [options]

Commands:
  init [--name <name>]    Register current git repo as a project
  list                    List all registered projects
  remove <name>           Remove a project from registry
  default <name>          Set default project

Options:
  --name <name>           Custom project name (default: directory name)
  -h, --help              Show this help

Examples:
  cd /path/to/myproject && wt-project init
  wt-project init --name myproj
  wt-project list
  wt-project default myproj
  wt-project remove myproj
EOF
}

cmd_init() {
    local name=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)
                name="$2"
                shift 2
                ;;
            *)
                error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done

    # Check if we're in a git repo
    if ! is_git_repo; then
        error "Current directory is not a git repository"
        echo "Please run this command from within a git repository."
        exit 1
    fi

    local git_root
    git_root=$(get_git_root)

    # Use directory name if no name specified
    if [[ -z "$name" ]]; then
        name=$(basename "$git_root")
    fi

    ensure_config

    # Check if we're in a worktree (not the main repo)
    local current_dir
    current_dir=$(git rev-parse --show-toplevel 2>/dev/null)
    local in_worktree=false
    if [[ "$current_dir" != "$git_root" ]]; then
        in_worktree=true
    fi

    # Check if project name already exists
    local existing_path
    existing_path=$(get_project_path "$name")
    if [[ -n "$existing_path" ]]; then
        if [[ "$existing_path" == "$git_root" ]]; then
            if $in_worktree; then
                info "Project '$name' already registered. Updating wt-tools deployment..."
                echo "  Main repo: $git_root"
            else
                info "Project '$name' already registered. Updating wt-tools deployment..."
            fi
            # Skip registration, proceed to deploy
        else
            error "Project name '$name' is already used for: $existing_path"
            echo "Use --name to specify a different name."
            exit 1
        fi
    else
        # Add project to registry
        local timestamp
        timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        local tmp
        tmp=$(mktemp)
        jq --arg name "$name" --arg path "$git_root" --arg ts "$timestamp" \
            '.projects[$name] = {"path": $path, "addedAt": $ts}' "$CONFIG_FILE" > "$tmp" && mv "$tmp" "$CONFIG_FILE"

        # Set as default if no default exists
        local current_default
        current_default=$(get_default_project)
        if [[ -z "$current_default" || "$current_default" == "null" ]]; then
            json_set "$CONFIG_FILE" ".default" "\"$name\""
            success "Project '$name' registered and set as default"
        else
            success "Project '$name' registered"
        fi
        echo "  Path: $git_root"
    fi

    # Deploy wt-tools to main repo
    echo ""
    info "Deploying wt-tools to $git_root..."
    deploy_wt_tools "$git_root"

    # If called from a worktree, also deploy to the worktree's own .claude/ dir
    # and register MCP for the worktree path scope
    if $in_worktree; then
        echo ""
        info "Deploying wt-tools to worktree $current_dir..."
        deploy_wt_tools "$current_dir"
    fi
    echo ""
    success "wt-tools deployment complete for '$name'"
}

cmd_list() {
    ensure_config

    local projects
    projects=$(jq -r '.projects | keys[]' "$CONFIG_FILE" 2>/dev/null)

    if [[ -z "$projects" ]]; then
        info "No projects registered."
        echo "Run 'wt-project init' inside a git repository to register it."
        exit 0
    fi

    local default_project
    default_project=$(get_default_project)

    echo "Registered projects:"
    echo ""

    while IFS= read -r name; do
        local path
        path=$(get_project_path "$name")
        if [[ "$name" == "$default_project" ]]; then
            echo -e "  ${GREEN}* $name${NC} -> $path"
        else
            echo "    $name -> $path"
        fi

        # Show worktrees for this project
        list_project_worktrees_brief "$name" "$path"
    done <<< "$projects"

    echo ""
    if [[ -n "$default_project" && "$default_project" != "null" ]]; then
        echo "Default: $default_project"
    fi
}

list_project_worktrees_brief() {
    local project_name="$1"
    local project_path="$2"

    if [[ ! -d "$project_path" ]]; then
        return
    fi

    # Get worktrees from git
    local worktrees
    worktrees=$(git -C "$project_path" worktree list --porcelain 2>/dev/null)

    if [[ -z "$worktrees" ]]; then
        return
    fi

    local current_path=""

    while IFS= read -r line; do
        if [[ "$line" =~ ^worktree\ (.+)$ ]]; then
            current_path="${BASH_REMATCH[1]}"
        elif [[ -z "$line" && -n "$current_path" ]]; then
            # Skip main repo, only show worktrees
            if [[ "$current_path" != "$project_path" ]]; then
                local wt_name
                wt_name=$(basename "$current_path")
                echo -e "      ${BLUE}└─ $wt_name${NC} -> $current_path"
            fi
            current_path=""
        fi
    done <<< "$worktrees"

    # Process last entry
    if [[ -n "$current_path" && "$current_path" != "$project_path" ]]; then
        local wt_name
        wt_name=$(basename "$current_path")
        echo -e "      ${BLUE}└─ $wt_name${NC} -> $current_path"
    fi
}

cmd_remove() {
    local name="$1"

    if [[ -z "$name" ]]; then
        error "Project name required"
        echo "Usage: wt-project remove <name>"
        exit 1
    fi

    ensure_config

    local path
    path=$(get_project_path "$name")
    if [[ -z "$path" ]]; then
        error "Project '$name' not found"
        exit 1
    fi

    # Remove from registry
    local tmp
    tmp=$(mktemp)
    jq --arg name "$name" 'del(.projects[$name])' "$CONFIG_FILE" > "$tmp" && mv "$tmp" "$CONFIG_FILE"

    # Clear default if this was the default
    local current_default
    current_default=$(get_default_project)
    if [[ "$current_default" == "$name" ]]; then
        json_set "$CONFIG_FILE" ".default" "null"
        warn "Cleared default project (was '$name')"
    fi

    success "Project '$name' removed from registry"
    echo "Note: Existing worktrees were not deleted."
}

cmd_default() {
    local name="$1"

    if [[ -z "$name" ]]; then
        error "Project name required"
        echo "Usage: wt-project default <name>"
        exit 1
    fi

    ensure_config

    local path
    path=$(get_project_path "$name")
    if [[ -z "$path" ]]; then
        error "Project '$name' not found"
        echo "Run 'wt-project list' to see available projects."
        exit 1
    fi

    json_set "$CONFIG_FILE" ".default" "\"$name\""
    success "Default project set to '$name'"
}

# Main
if [[ $# -eq 0 ]]; then
    usage
    exit 1
fi

case "$1" in
    init)
        shift
        cmd_init "$@"
        ;;
    list|ls)
        cmd_list
        ;;
    remove|rm)
        shift
        cmd_remove "$@"
        ;;
    default)
        shift
        cmd_default "$@"
        ;;
    -h|--help|help)
        usage
        ;;
    *)
        error "Unknown command: $1"
        usage
        exit 1
        ;;
esac
