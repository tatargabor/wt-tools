#!/usr/bin/env bash
# wt-hook-memory-pretool - Claude Code PreToolUse hook for hot-topic recall
#
# L3: Pattern-matches Bash commands against discovered hot topics + generic base.
# Exits immediately (~2ms) on no match. On match, recalls relevant memories (~150ms).
#
# Designed to be referenced by name in .claude/settings.json:
#   "PreToolUse": [{"matcher": "Bash", "hooks": [{"type": "command", "command": "wt-hook-memory-pretool", "timeout": 5}]}]

INPUT=$(cat)

# Only run if wt-memory is available and healthy
command -v wt-memory &>/dev/null || exit 0
wt-memory health &>/dev/null || exit 0

# Extract command from tool_input
COMMAND=$(echo "$INPUT" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    print(data.get('tool_input', {}).get('command', ''))
except:
    pass
" 2>/dev/null)

[[ -z "$COMMAND" ]] && exit 0

# --- Build pattern list: generic base + discovered ---
# Generic base patterns (always active)
BASE_PATTERNS='ssh\s|scp\s|rm\s+-rf|drop\s|truncate\s|DELETE\s+FROM|sudo\s|docker\s|kubectl\s|podman\s'

# Load discovered patterns from cache
DISCOVERED=""
PROJECT_DIR="${CLAUDE_PROJECT_DIR:-$(pwd)}"
CACHE_FILE="$PROJECT_DIR/.claude/hot-topics.json"

if [[ -f "$CACHE_FILE" ]]; then
    DISCOVERED=$(python3 -c "
import json, sys
try:
    with open('$CACHE_FILE') as f:
        data = json.load(f)
    patterns = data.get('patterns', []) + data.get('promoted', [])
    # Build regex alternation from patterns
    if patterns:
        print('|'.join(patterns))
except:
    pass
" 2>/dev/null)
fi

# Combine patterns
if [[ -n "$DISCOVERED" ]]; then
    ALL_PATTERNS="$BASE_PATTERNS|$DISCOVERED"
else
    ALL_PATTERNS="$BASE_PATTERNS"
fi

# --- Fast regex check ---
MATCHED=$(echo "$COMMAND" | python3 -c "
import sys, re
command = sys.stdin.read().strip()
pattern = sys.argv[1]
try:
    if re.search(pattern, command):
        # Extract the first matching word/token for the recall query
        m = re.search(pattern, command)
        # Get the matched text + surrounding context
        start = max(0, m.start() - 10)
        end = min(len(command), m.end() + 30)
        print(command[start:end].strip())
    else:
        sys.exit(1)
except:
    sys.exit(1)
" "$ALL_PATTERNS" 2>/dev/null)

[[ -z "$MATCHED" ]] && exit 0

# --- Hot-topic match! Recall relevant memories ---
TMPFILE=$(mktemp)
trap "rm -f $TMPFILE" EXIT

# Use the matched command portion as recall query
RECALL_QUERY="$MATCHED"
wt-memory recall "$RECALL_QUERY" --limit 2 --mode hybrid 2>/dev/null > "$TMPFILE" || exit 0

CONTENT=$(cat "$TMPFILE")
[[ -z "$CONTENT" || "$CONTENT" == "[]" ]] && exit 0

# Format memories
FORMATTED=$(python3 -c "
import sys, json
try:
    memories = json.load(sys.stdin)
except: sys.exit(0)
if not memories: sys.exit(0)
seen = set()
for m in memories:
    c = m.get('content','').replace('\n',' ')[:200]
    key = c[:50]
    if key in seen: continue
    seen.add(key)
    print(f'  - {c}')
" < "$TMPFILE" 2>/dev/null)

[[ -z "$FORMATTED" ]] && exit 0

# Output as additionalContext JSON
CONTEXT_TEXT="=== MEMORY: Context for this command ===\n$FORMATTED"

python3 -c "
import json, sys
text = sys.argv[1]
output = {
    'hookSpecificOutput': {
        'hookEventName': 'PreToolUse',
        'additionalContext': text
    }
}
print(json.dumps(output))
" "$CONTEXT_TEXT" 2>/dev/null

exit 0
