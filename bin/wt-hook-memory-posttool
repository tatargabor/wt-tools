#!/usr/bin/env bash
# wt-hook-memory-posttool - Claude Code PostToolUseFailure hook for error recovery
#
# L4: Fires on Bash errors. Parses error text as recall query to surface past fixes.
# Also auto-promotes the failed command to hot topics so L3 catches it next time.
#
# Designed to be referenced by name in .claude/settings.json:
#   "PostToolUseFailure": [{"matcher": "Bash", "hooks": [{"type": "command", "command": "wt-hook-memory-posttool", "timeout": 5}]}]

INPUT=$(cat)

# Only run if wt-memory is available and healthy
command -v wt-memory &>/dev/null || exit 0
wt-memory health &>/dev/null || exit 0

# Parse error info from hook input
PARSED=$(echo "$INPUT" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    error = data.get('error', '')
    is_interrupt = data.get('is_interrupt', False)
    command = data.get('tool_input', {}).get('command', '')
    print(f'{is_interrupt}|||{error}|||{command}')
except:
    print('|||')
" 2>/dev/null)

IS_INTERRUPT="${PARSED%%|||*}"
REST="${PARSED#*|||}"
ERROR_TEXT="${REST%%|||*}"
COMMAND="${REST##*|||}"

# Skip if user interrupt
[[ "$IS_INTERRUPT" == "True" || "$IS_INTERRUPT" == "true" ]] && exit 0

# Skip if error text too short
[[ ${#ERROR_TEXT} -lt 10 ]] && exit 0

# --- Auto-promote failed command to hot topics ---
# Trivial commands that should never be promoted
TRIVIAL='ls|cat|head|tail|echo|cd|pwd|mkdir|cp|mv|touch|chmod|chown|wc|sort|grep|find|which|test|true|false|exit|printf|rm|stat|readlink|basename|dirname|date|sleep'

# Extract first command token
CMD_PREFIX=$(echo "$COMMAND" | python3 -c "
import sys, re, shlex
cmd = sys.stdin.read().strip()
# Skip env var assignments at start
cmd = re.sub(r'^(\w+=\S+\s+)+', '', cmd)
# Get first token (command name)
try:
    tokens = shlex.split(cmd)
except:
    tokens = cmd.split()
if tokens:
    # Strip path prefix
    name = tokens[0].split('/')[-1]
    print(name)
" 2>/dev/null)

if [[ -n "$CMD_PREFIX" ]]; then
    # Check if trivial
    IS_TRIVIAL=$(echo "$CMD_PREFIX" | python3 -c "
import sys, re
cmd = sys.stdin.read().strip()
trivial = sys.argv[1]
if re.match(f'^({trivial})$', cmd):
    print('yes')
else:
    print('no')
" "$TRIVIAL" 2>/dev/null)

    if [[ "$IS_TRIVIAL" != "yes" ]]; then
        # Promote to hot topics cache
        PROJECT_DIR="${CLAUDE_PROJECT_DIR:-$(pwd)}"
        CACHE_FILE="$PROJECT_DIR/.claude/hot-topics.json"

        python3 -c "
import json, sys, os
cmd_prefix = sys.argv[1]
cache_file = sys.argv[2]

data = {'patterns': [], 'promoted': [], 'generated_at': ''}
if os.path.exists(cache_file):
    try:
        with open(cache_file) as f:
            data = json.load(f)
    except:
        pass

# Add to promoted if not already present
promoted = data.get('promoted', [])
all_patterns = data.get('patterns', []) + promoted
if cmd_prefix not in all_patterns:
    promoted.append(cmd_prefix)
    data['promoted'] = promoted
    os.makedirs(os.path.dirname(cache_file), exist_ok=True)
    with open(cache_file, 'w') as f:
        json.dump(data, f, indent=2)
" "$CMD_PREFIX" "$CACHE_FILE" 2>/dev/null
    fi
fi

# --- Recall past fixes for this error ---
TMPFILE=$(mktemp)
trap "rm -f $TMPFILE" EXIT

# Use first 300 chars of error text as recall query
RECALL_QUERY=$(echo "$ERROR_TEXT" | head -c 300)
wt-memory recall "$RECALL_QUERY" --limit 3 --mode hybrid 2>/dev/null > "$TMPFILE" || exit 0

CONTENT=$(cat "$TMPFILE")
[[ -z "$CONTENT" || "$CONTENT" == "[]" ]] && exit 0

# Format memories
FORMATTED=$(python3 -c "
import sys, json
try:
    memories = json.load(sys.stdin)
except: sys.exit(0)
if not memories: sys.exit(0)
seen = set()
for m in memories:
    c = m.get('content','').replace('\n',' ')[:300]
    key = c[:50]
    if key in seen: continue
    seen.add(key)
    print(f'  - {c}')
" < "$TMPFILE" 2>/dev/null)

[[ -z "$FORMATTED" ]] && exit 0

# Output as additionalContext JSON
CONTEXT_TEXT="=== MEMORY: Past fix for this error ===\n$FORMATTED"

python3 -c "
import json, sys
text = sys.argv[1]
output = {
    'hookSpecificOutput': {
        'hookEventName': 'PostToolUseFailure',
        'additionalContext': text
    }
}
print(json.dumps(output))
" "$CONTEXT_TEXT" 2>/dev/null

exit 0
