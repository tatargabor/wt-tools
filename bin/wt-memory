#!/usr/bin/env bash
# wt-memory - CLI helper for Shodh-Memory (Python library)
# Provides per-project remember/recall operations with graceful degradation.
# If shodh-memory is not installed, all commands silently succeed (no-op).

set -euo pipefail

# Storage root (override with env var). Per-project dirs created underneath.
SHODH_STORAGE="${SHODH_STORAGE:-${HOME}/.local/share/wt-tools/memory}"

# Global --project override (set by main before dispatch)
PROJECT=""

usage() {
    cat <<EOF
Usage: wt-memory <command> [options]

CLI helper for Shodh-Memory (local per-project cognitive memory).

Core Commands:
  health                          Check if shodh-memory is available
  remember --type TYPE [--tags t1,t2] < content
                                  Save a memory (reads content from stdin)
  recall "query" [--limit N] [--mode MODE] [--tags t1,t2]
                                  Semantic search (JSON stdout)
  list [--type TYPE] [--limit N]  List memories (JSON stdout)
  status [--json]                 Show config, health, and memory count
  projects                        List all projects with memory counts

Forget / Cleanup:
  forget <id>                     Delete a single memory by ID
  forget --all --confirm          Delete ALL memories (requires --confirm)
  forget --older-than <days>      Delete memories older than N days
  forget --tags <t1,t2>           Delete memories matching tags
  forget --pattern <regex>        Delete memories matching regex pattern

Introspection:
  get <id>                        Get a single memory by ID (JSON stdout)
  context [topic]                 Condensed summary by category
  brain                           3-tier memory visualization

Maintenance:
  health --index                  Check index health (JSON stdout)
  repair                          Repair index integrity

Recall modes (--mode):
  semantic     Meaning-based search (default)
  temporal     Time-based relevance
  hybrid       Combined semantic + temporal
  causal       Cause-effect relationships
  associative  Related concept discovery

Valid types for --type:
  Decision    A technical choice or preference
  Learning    A discovered pattern, gotcha, or lesson
  Context     Background info, events, or general notes

  Legacy aliases (mapped automatically with a warning):
    Observation → Learning
    Event       → Context

Global options:
  --project NAME                  Override project name (default: auto-detect from git root)

Environment:
  SHODH_STORAGE   Storage root (default: ~/.local/share/wt-tools/memory)

Graceful degradation:
  If shodh-memory is not installed, commands exit silently (exit 0)
  with empty JSON output.
EOF
}

# Resolve project name from git root or --project flag.
# For worktrees, resolves to the main repo name so all worktrees share memory.
resolve_project() {
    if [[ -n "$PROJECT" ]]; then
        echo "$PROJECT"
        return 0
    fi

    # Auto-detect from git root
    local toplevel
    toplevel=$(git rev-parse --show-toplevel 2>/dev/null) || true
    if [[ -z "$toplevel" ]]; then
        echo "_global"
        return 0
    fi

    # Check if this is a worktree — git-common-dir points to main repo's .git
    local common_dir
    common_dir=$(git rev-parse --git-common-dir 2>/dev/null) || true

    if [[ -n "$common_dir" && "$common_dir" != ".git" ]]; then
        # Worktree: common_dir is /path/to/main-repo/.git (absolute or relative)
        local abs_common
        abs_common=$(cd "$toplevel" && cd "$common_dir" && pwd)
        basename "$(dirname "$abs_common")"
    else
        # Main repo
        basename "$toplevel"
    fi
}

# Get the per-project storage path
get_storage_path() {
    local project
    project=$(resolve_project)

    # Legacy detection: if .sst files exist directly in SHODH_STORAGE root,
    # and we'd resolve to _global, use _legacy instead
    if [[ "$project" == "_global" ]] && ls "$SHODH_STORAGE"/*.sst >/dev/null 2>&1; then
        echo "$SHODH_STORAGE/_legacy"
        return 0
    fi

    echo "$SHODH_STORAGE/$project"
}

# Get the per-project log file path for error logging
get_log_path() {
    local storage_path
    storage_path=$(get_storage_path)
    mkdir -p "$storage_path"
    echo "$storage_path/wt-memory.log"
}

# Run python3 with shodh-memory.
# Banner suppressed at Python level (sys._shodh_star_shown).
# Stderr goes to log file for diagnosis (not /dev/null).
run_shodh_python() {
    local log_file
    log_file=$(get_log_path)
    python3 "$@" 2>>"$log_file"
}

# Run a command under a per-project flock to prevent concurrent RocksDB access.
# Uses fd-based flock so it works with bash functions (not just external commands).
# Usage: run_with_lock <command> [args...]
run_with_lock() {
    local project
    project=$(resolve_project)
    local lock_file="/tmp/wt-memory-${project}.lock"
    (
        flock --timeout 10 9 || { echo "wt-memory: lock timeout after 10s" >&2; return 1; }
        "$@"
    ) 9>"$lock_file"
}

# Check if shodh-memory Python package is importable
# No flock needed — does not open the DB, just imports.
# Stderr suppressed — expected to fail when not installed.
cmd_health() {
    local index_check=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --index) index_check=true; shift ;;
            *) shift ;;
        esac
    done

    if ! python3 -c "import sys; sys._shodh_star_shown = True; from shodh_memory import Memory" 2>/dev/null; then
        if [[ "$index_check" == "true" ]]; then
            echo "{}"
        fi
        return 1
    fi

    if [[ "$index_check" == "true" ]]; then
        local storage_path
        storage_path=$(get_storage_path)
        _SHODH_STORAGE="$storage_path" \
        run_with_lock run_shodh_python -c "
import sys; sys._shodh_star_shown = True
import json, os
from shodh_memory import Memory
m = Memory(storage_path=os.environ['_SHODH_STORAGE'])
try:
    result = m.index_health()
    print(json.dumps(result, default=str))
except AttributeError:
    print(json.dumps({'error': 'index_health not available in this shodh-memory version'}))
" || echo "{}"
    else
        echo "ok"
    fi
    return 0
}

# Save a memory: reads content from stdin
# Usage: echo "content" | wt-memory remember --type Decision --tags repo,change
cmd_remember() {
    local memory_type=""
    local tags=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --type) memory_type="$2"; shift 2 ;;
            --tags) tags="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    if [[ -z "$memory_type" ]]; then
        echo "Error: --type is required" >&2
        return 1
    fi

    # Map unsupported types to valid shodh-memory types
    case "$memory_type" in
        Observation|observation)
            echo "Note: type '$memory_type' mapped to 'Learning'" >&2
            memory_type="Learning"
            ;;
        Event|event)
            echo "Note: type '$memory_type' mapped to 'Context'" >&2
            memory_type="Context"
            ;;
    esac

    # Read content from stdin
    local content
    content=$(cat)

    if [[ -z "$content" ]]; then
        return 0
    fi

    # Health check — silent no-op if not installed
    if ! cmd_health >/dev/null 2>&1; then
        return 0
    fi

    local storage_path
    storage_path=$(get_storage_path)
    mkdir -p "$storage_path"

    # Build tags as Python list
    local tags_py="[]"
    if [[ -n "$tags" ]]; then
        tags_py=$(echo "$tags" | tr ',' '\n' | jq -R . | jq -s .)
    fi

    # Pass data via env vars to avoid shell escaping issues
    local rc=0
    _SHODH_STORAGE="$storage_path" \
    _SHODH_CONTENT="$content" \
    _SHODH_TYPE="$memory_type" \
    _SHODH_TAGS="$tags_py" \
    run_with_lock run_shodh_python -c "
import sys; sys._shodh_star_shown = True
import json, os
from shodh_memory import Memory
m = Memory(storage_path=os.environ['_SHODH_STORAGE'])
tags = json.loads(os.environ['_SHODH_TAGS'])
m.remember(os.environ['_SHODH_CONTENT'], memory_type=os.environ['_SHODH_TYPE'], tags=tags)
" || rc=$?

    if [[ $rc -ne 0 ]]; then
        echo "wt-memory remember: failed (exit $rc), see $(get_log_path)" >&2
    fi
    return 0
}

# Forget (delete) memories
# Usage: wt-memory forget <id>
#        wt-memory forget --all --confirm
#        wt-memory forget --older-than <days>
#        wt-memory forget --tags <t1,t2>
#        wt-memory forget --pattern <regex>
cmd_forget() {
    local memory_id=""
    local forget_all=false
    local confirm=false
    local older_than=""
    local tags=""
    local pattern=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --all) forget_all=true; shift ;;
            --confirm) confirm=true; shift ;;
            --older-than) older_than="$2"; shift 2 ;;
            --tags) tags="$2"; shift 2 ;;
            --pattern) pattern="$2"; shift 2 ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                return 1
                ;;
            *)
                if [[ -z "$memory_id" ]]; then
                    memory_id="$1"
                fi
                shift
                ;;
        esac
    done

    # Health check — silent no-op if not installed
    if ! cmd_health >/dev/null 2>&1; then
        return 0
    fi

    local storage_path
    storage_path=$(get_storage_path)

    # forget --all --confirm
    if [[ "$forget_all" == "true" ]]; then
        if [[ "$confirm" != "true" ]]; then
            echo "Error: --all requires --confirm to prevent accidental deletion" >&2
            return 1
        fi
        local rc=0
        _SHODH_STORAGE="$storage_path" \
        run_with_lock run_shodh_python -c "
import sys; sys._shodh_star_shown = True
import json, os
from shodh_memory import Memory
m = Memory(storage_path=os.environ['_SHODH_STORAGE'])
count = m.forget_all()
print(json.dumps({'deleted_count': count}))
" || rc=$?
        return 0
    fi

    # forget --older-than <days>
    if [[ -n "$older_than" ]]; then
        _SHODH_STORAGE="$storage_path" \
        _SHODH_DAYS="$older_than" \
        run_with_lock run_shodh_python -c "
import sys; sys._shodh_star_shown = True
import json, os
from shodh_memory import Memory
m = Memory(storage_path=os.environ['_SHODH_STORAGE'])
count = m.forget_by_age(int(os.environ['_SHODH_DAYS']))
print(json.dumps({'deleted_count': count}))
" || echo '{"deleted_count": 0}'
        return 0
    fi

    # forget --tags <t1,t2>
    if [[ -n "$tags" ]]; then
        local tags_py
        tags_py=$(echo "$tags" | tr ',' '\n' | jq -R . | jq -s .)
        _SHODH_STORAGE="$storage_path" \
        _SHODH_TAGS="$tags_py" \
        run_with_lock run_shodh_python -c "
import sys; sys._shodh_star_shown = True
import json, os
from shodh_memory import Memory
m = Memory(storage_path=os.environ['_SHODH_STORAGE'])
tags = json.loads(os.environ['_SHODH_TAGS'])
count = m.forget_by_tags(tags)
print(json.dumps({'deleted_count': count}))
" || echo '{"deleted_count": 0}'
        return 0
    fi

    # forget --pattern <regex>
    if [[ -n "$pattern" ]]; then
        _SHODH_STORAGE="$storage_path" \
        _SHODH_PATTERN="$pattern" \
        run_with_lock run_shodh_python -c "
import sys; sys._shodh_star_shown = True
import json, os
from shodh_memory import Memory
m = Memory(storage_path=os.environ['_SHODH_STORAGE'])
count = m.forget_by_pattern(os.environ['_SHODH_PATTERN'])
print(json.dumps({'deleted_count': count}))
" || echo '{"deleted_count": 0}'
        return 0
    fi

    # forget <id> — single memory delete
    if [[ -n "$memory_id" ]]; then
        _SHODH_STORAGE="$storage_path" \
        _SHODH_ID="$memory_id" \
        run_with_lock run_shodh_python -c "
import sys; sys._shodh_star_shown = True
import json, os
from shodh_memory import Memory
m = Memory(storage_path=os.environ['_SHODH_STORAGE'])
result = m.forget(os.environ['_SHODH_ID'])
print(json.dumps({'deleted': bool(result), 'id': os.environ['_SHODH_ID']}))
" || echo "{\"deleted\": false, \"id\": \"$memory_id\"}"
        return 0
    fi

    echo "Error: specify a memory ID, or use --all, --older-than, --tags, or --pattern" >&2
    return 1
}

# Semantic search
# Usage: wt-memory recall "query" --limit 5 --mode hybrid --tags t1,t2
cmd_recall() {
    local query=""
    local limit=5
    local mode=""
    local tags=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --limit) limit="$2"; shift 2 ;;
            --mode) mode="$2"; shift 2 ;;
            --tags) tags="$2"; shift 2 ;;
            -*)
                shift
                ;;
            *)
                if [[ -z "$query" ]]; then
                    query="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$query" ]]; then
        echo "[]"
        return 0
    fi

    # Health check — return empty array if not installed
    if ! cmd_health >/dev/null 2>&1; then
        echo "[]"
        return 0
    fi

    local storage_path
    storage_path=$(get_storage_path)

    # Build tags as Python list
    local tags_py="[]"
    if [[ -n "$tags" ]]; then
        tags_py=$(echo "$tags" | tr ',' '\n' | jq -R . | jq -s .)
    fi

    _SHODH_STORAGE="$storage_path" \
    _SHODH_QUERY="$query" \
    _SHODH_LIMIT="$limit" \
    _SHODH_MODE="$mode" \
    _SHODH_TAGS="$tags_py" \
    run_with_lock run_shodh_python -c "
import sys; sys._shodh_star_shown = True
import json, os
from shodh_memory import Memory
m = Memory(storage_path=os.environ['_SHODH_STORAGE'])
kwargs = {'limit': int(os.environ['_SHODH_LIMIT'])}
mode = os.environ.get('_SHODH_MODE', '')
if mode:
    kwargs['mode'] = mode
tags = json.loads(os.environ.get('_SHODH_TAGS', '[]'))
if tags:
    kwargs['tags'] = tags
results = m.recall(os.environ['_SHODH_QUERY'], **kwargs)
print(json.dumps(results, default=str))
" || echo "[]"

    return 0
}

# List all memories for current project
# Usage: wt-memory list [--type Decision] [--limit 20]
cmd_list() {
    local memory_type=""
    local limit=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --type) memory_type="$2"; shift 2 ;;
            --limit) limit="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    # Health check — return empty array if not installed
    if ! cmd_health >/dev/null 2>&1; then
        echo "[]"
        return 0
    fi

    local storage_path
    storage_path=$(get_storage_path)

    # If storage dir doesn't exist yet, no memories
    if [[ ! -d "$storage_path" ]]; then
        echo "[]"
        return 0
    fi

    _SHODH_STORAGE="$storage_path" \
    _SHODH_TYPE="$memory_type" \
    _SHODH_LIMIT="$limit" \
    run_with_lock run_shodh_python -c "
import sys; sys._shodh_star_shown = True
import json, os
from shodh_memory import Memory
m = Memory(storage_path=os.environ['_SHODH_STORAGE'])
kwargs = {}
mt = os.environ.get('_SHODH_TYPE', '')
if mt:
    kwargs['memory_type'] = mt
lim = os.environ.get('_SHODH_LIMIT', '')
if lim:
    kwargs['limit'] = int(lim)
memories = m.list_memories(**kwargs)
print(json.dumps(memories, default=str))
" || echo "[]"

    return 0
}

# Context summary by category
# Usage: wt-memory context [topic]
cmd_context() {
    local topic=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -*) shift ;;
            *)
                if [[ -z "$topic" ]]; then
                    topic="$1"
                fi
                shift
                ;;
        esac
    done

    if ! cmd_health >/dev/null 2>&1; then
        echo "{}"
        return 0
    fi

    local storage_path
    storage_path=$(get_storage_path)

    _SHODH_STORAGE="$storage_path" \
    _SHODH_TOPIC="$topic" \
    run_with_lock run_shodh_python -c "
import sys; sys._shodh_star_shown = True
import json, os
from shodh_memory import Memory
m = Memory(storage_path=os.environ['_SHODH_STORAGE'])
topic = os.environ.get('_SHODH_TOPIC', '')
try:
    if topic:
        result = m.context_summary(max_items=5, include_decisions=True, include_learnings=True, include_context=True)
    else:
        result = m.context_summary(max_items=5, include_decisions=True, include_learnings=True, include_context=True)
    print(json.dumps(result, default=str))
except AttributeError:
    print(json.dumps({'error': 'context_summary not available in this shodh-memory version'}))
" || echo "{}"

    return 0
}

# 3-tier memory visualization
# Usage: wt-memory brain
cmd_brain() {
    if ! cmd_health >/dev/null 2>&1; then
        echo "{}"
        return 0
    fi

    local storage_path
    storage_path=$(get_storage_path)

    _SHODH_STORAGE="$storage_path" \
    run_with_lock run_shodh_python -c "
import sys; sys._shodh_star_shown = True
import json, os
from shodh_memory import Memory
m = Memory(storage_path=os.environ['_SHODH_STORAGE'])
try:
    result = m.brain_state(longterm_limit=100)
    print(json.dumps(result, default=str))
except AttributeError:
    print(json.dumps({'error': 'brain_state not available in this shodh-memory version'}))
" || echo "{}"

    return 0
}

# Get single memory by ID
# Usage: wt-memory get <memory_id>
cmd_get() {
    local memory_id=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -*) shift ;;
            *)
                if [[ -z "$memory_id" ]]; then
                    memory_id="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$memory_id" ]]; then
        echo "Error: memory ID required" >&2
        return 1
    fi

    if ! cmd_health >/dev/null 2>&1; then
        echo "{}"
        return 0
    fi

    local storage_path
    storage_path=$(get_storage_path)

    _SHODH_STORAGE="$storage_path" \
    _SHODH_ID="$memory_id" \
    run_with_lock run_shodh_python -c "
import sys; sys._shodh_star_shown = True
import json, os
from shodh_memory import Memory
m = Memory(storage_path=os.environ['_SHODH_STORAGE'])
try:
    result = m.get_memory(os.environ['_SHODH_ID'])
    print(json.dumps(result, default=str))
except Exception:
    print('{}')
" || echo "{}"

    return 0
}

# Repair index integrity
# Usage: wt-memory repair
cmd_repair() {
    if ! cmd_health >/dev/null 2>&1; then
        echo "{}"
        return 0
    fi

    local storage_path
    storage_path=$(get_storage_path)
    mkdir -p "$storage_path"

    _SHODH_STORAGE="$storage_path" \
    run_with_lock run_shodh_python -c "
import sys; sys._shodh_star_shown = True
import json, os
from shodh_memory import Memory
m = Memory(storage_path=os.environ['_SHODH_STORAGE'])
try:
    result = m.repair_index()
    print(json.dumps(result, default=str))
except AttributeError:
    print(json.dumps({'error': 'repair_index not available in this shodh-memory version'}))
" || echo "{}"

    return 0
}

# Show configuration and health status
cmd_status() {
    local json_mode=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json) json_mode=true; shift ;;
            *) shift ;;
        esac
    done

    local project
    project=$(resolve_project)
    local storage_path
    storage_path=$(get_storage_path)

    if [[ "$json_mode" == "true" ]]; then
        # JSON output for GUI consumption
        if cmd_health >/dev/null 2>&1; then
            local count
            count=$(_SHODH_STORAGE="$storage_path" run_with_lock run_shodh_python -c "
import sys; sys._shodh_star_shown = True
import os
from shodh_memory import Memory
m = Memory(storage_path=os.environ['_SHODH_STORAGE'])
stats = m.get_stats()
print(stats.get('total_memories', 0))
") || count=0
            [[ "$count" =~ ^[0-9]+$ ]] || count=0
            echo "{\"available\": true, \"project\": \"$project\", \"count\": $count, \"storage_path\": \"$storage_path\"}"
        else
            echo "{\"available\": false, \"project\": \"$project\", \"count\": 0, \"storage_path\": \"$storage_path\"}"
        fi
    else
        # Human-readable output
        echo "Shodh-Memory Configuration:"
        echo "  Project: $project"
        echo "  Storage: $storage_path"
        echo ""

        echo -n "Health: "
        if cmd_health >/dev/null 2>&1; then
            echo "available"
            _SHODH_STORAGE="$storage_path" run_with_lock run_shodh_python -c "
import sys; sys._shodh_star_shown = True
import os
from shodh_memory import Memory
m = Memory(storage_path=os.environ['_SHODH_STORAGE'])
stats = m.get_stats()
print(f'  Memories: {stats.get(\"total_memories\", \"?\")}')" || true
        else
            echo "not installed"
            echo ""
            echo "Install:"
            echo "  pip install shodh-memory"
        fi
    fi
}

# List all projects with memory counts
cmd_projects() {
    if [[ ! -d "$SHODH_STORAGE" ]]; then
        echo "No memory storage found at $SHODH_STORAGE"
        return 0
    fi

    local has_projects=false

    for dir in "$SHODH_STORAGE"/*/; do
        [[ -d "$dir" ]] || continue
        local proj_name
        proj_name=$(basename "$dir")

        # Skip if it's not a shodh-memory storage (no memories subdir)
        [[ -d "$dir/memories" ]] || [[ -d "$dir/memory_index" ]] || continue

        has_projects=true

        if cmd_health >/dev/null 2>&1; then
            local count
            count=$(_SHODH_STORAGE="$dir" run_shodh_python -c "
import sys; sys._shodh_star_shown = True
import os
from shodh_memory import Memory
m = Memory(storage_path=os.environ['_SHODH_STORAGE'])
stats = m.get_stats()
print(stats.get('total_memories', 0))
") || count="?"
            echo "  $proj_name: $count memories"
        else
            echo "  $proj_name: (shodh-memory not installed)"
        fi
    done

    # Check for legacy storage (sst files directly in root)
    if ls "$SHODH_STORAGE"/*.sst >/dev/null 2>&1; then
        has_projects=true
        echo "  _legacy: (unmigrared global storage)"
    fi

    if [[ "$has_projects" == "false" ]]; then
        echo "No projects with memories found."
    fi
}

# Main dispatch — parse global --project flag before command
main() {
    # Parse global options before command
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project)
                PROJECT="$2"
                shift 2
                ;;
            *)
                break
                ;;
        esac
    done

    if [[ $# -eq 0 ]]; then
        usage
        exit 0
    fi

    local command="$1"
    shift

    case "$command" in
        health)   cmd_health "$@" ;;
        remember) cmd_remember "$@" ;;
        recall)   cmd_recall "$@" ;;
        list)     cmd_list "$@" ;;
        forget)   cmd_forget "$@" ;;
        context)  cmd_context "$@" ;;
        brain)    cmd_brain "$@" ;;
        get|inspect) cmd_get "$@" ;;
        repair)   cmd_repair "$@" ;;
        status)   cmd_status "$@" ;;
        projects) cmd_projects "$@" ;;
        -h|--help|help) usage ;;
        *)
            echo "Error: Unknown command '$command'" >&2
            usage
            exit 1
            ;;
    esac
}

main "$@"
