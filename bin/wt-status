#!/usr/bin/env bash
# wt-status - Display worktree and agent status

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/wt-common.sh"

# Status icons
ICON_RUNNING="●"
ICON_WAITING="⚡"
ICON_IDLE="○"
ICON_DONE="✓"

# Find the window that owns an agent process by walking the PPID chain
# Args: $1 = agent PID
# Returns (stdout): "window_id|process_name" if found, empty if not
# The PPID chain walks from the agent up through parent processes until
# finding one that owns a window (max 20 levels).
find_window_for_agent() {
    local agent_pid="$1"
    local current_pid="$agent_pid"
    local depth=0
    local max_depth=20

    case "$PLATFORM" in
        linux)
            if command -v xdotool &>/dev/null; then
                while [[ "$depth" -lt "$max_depth" && "$current_pid" -gt 1 ]] 2>/dev/null; do
                    # Check if this process owns any X11 window
                    local wid
                    wid=$(xdotool search --pid "$current_pid" 2>/dev/null | head -1) || true
                    if [[ -n "$wid" ]]; then
                        # Found a window - get the process name
                        local proc_name
                        proc_name=$(ps -o comm= -p "$current_pid" 2>/dev/null | tr -d ' ') || proc_name="unknown"
                        echo "$wid|$proc_name"
                        return 0
                    fi

                    # Walk up to parent
                    local ppid
                    ppid=$(ps -o ppid= -p "$current_pid" 2>/dev/null | tr -d ' ') || break
                    [[ -z "$ppid" || "$ppid" == "$current_pid" ]] && break
                    current_pid="$ppid"
                    ((depth++))
                done
            fi
            ;;
        macos)
            while [[ "$depth" -lt "$max_depth" && "$current_pid" -gt 1 ]] 2>/dev/null; do
                # Check if this process has windows via AppleScript
                local result
                result=$(osascript -e "
                    tell application \"System Events\"
                        try
                            set targetProc to first process whose unix id is $current_pid
                            if (count of windows of targetProc) > 0 then
                                return name of targetProc & \"|\" & (id of first window of targetProc)
                            end if
                        end try
                    end tell
                " 2>/dev/null) || true

                if [[ -n "$result" ]]; then
                    local proc_name="${result%%|*}"
                    local wid="${result#*|}"
                    echo "$wid|$proc_name"
                    return 0
                fi

                # Walk up to parent
                local ppid
                ppid=$(ps -o ppid= -p "$current_pid" 2>/dev/null | tr -d ' ') || break
                [[ -z "$ppid" || "$ppid" == "$current_pid" ]] && break
                current_pid="$ppid"
                ((depth++))
            done
            ;;
    esac

    return 1
}

# Check if an editor window is open for a given worktree
# Uses PPID chain walking when agents exist, falls back to TTY check
# Args: $1 = worktree path, $2 = "true" if main repo
# Sets global: _last_window_id, _last_editor_type
# Returns: 0 (true) if editor window found, 1 (false) otherwise
_last_window_id=""
_last_editor_type=""
is_editor_open() {
    local wt_path="$1"
    local is_main="${2:-false}"
    _last_window_id=""
    _last_editor_type=""

    # Try PPID chain detection using agent PIDs in this worktree
    local agent_pids
    agent_pids=$(ps -e -o pid=,comm= | awk '$2 == "claude" {print $1}') || true

    if [[ -n "$agent_pids" ]]; then
        while read -r pid; do
            [[ -z "$pid" ]] && continue

            # Check if this agent is in this worktree
            local proc_cwd
            proc_cwd=$(get_proc_cwd "$pid") || continue
            [[ -z "$proc_cwd" ]] && continue
            if [[ "$proc_cwd" != "$wt_path" && "$proc_cwd" != "$wt_path/"* ]]; then
                continue
            fi

            # Found an agent in this worktree - walk its PPID chain
            local result
            result=$(find_window_for_agent "$pid") || true
            if [[ -n "$result" ]]; then
                _last_window_id="${result%%|*}"
                _last_editor_type="${result#*|}"
                return 0
            fi

            # No window found - check TTY as fallback (remote session)
            local tty
            tty=$(ps -o tty= -p "$pid" 2>/dev/null | tr -d ' ')
            if [[ -n "$tty" && "$tty" != "?" && "$tty" != "??" ]]; then
                # Has a TTY - likely remote/interactive session, not orphan
                _last_editor_type="terminal"
                return 0
            fi
        done <<< "$agent_pids"
    fi

    # No agents or no windows found via PPID chain — try title-based search
    local wt_basename
    wt_basename=$(basename "$wt_path")

    case "$PLATFORM" in
        linux)
            if command -v xdotool &>/dev/null; then
                # Search for window whose title contains the worktree basename
                # (Zed appends " — filename" to the title, so exact match won't work)
                local wid
                wid=$(xdotool search --name "$wt_basename" 2>/dev/null | head -1) || true
                if [[ -n "$wid" ]]; then
                    _last_window_id="$wid"
                    local proc_pid
                    proc_pid=$(xdotool getwindowpid "$wid" 2>/dev/null) || true
                    if [[ -n "$proc_pid" ]]; then
                        _last_editor_type=$(ps -o comm= -p "$proc_pid" 2>/dev/null | tr -d ' ') || _last_editor_type="unknown"
                    fi
                    return 0
                fi
            fi
            ;;
        macos)
            local found
            found=$(osascript -e "
                tell application \"System Events\"
                    repeat with proc in (every process whose background only is false)
                        repeat with win in windows of proc
                            if name of win contains \"$wt_basename\" then
                                return (unix id of proc) & \"|\" & (name of proc) & \"|\" & (id of win)
                            end if
                        end repeat
                    end repeat
                end tell
                return \"\"
            " 2>/dev/null) || true
            if [[ -n "$found" ]]; then
                local proc_name wid
                wid="${found##*|}"
                found="${found%|*}"
                proc_name="${found#*|}"
                _last_window_id="$wid"
                _last_editor_type="$proc_name"
                return 0
            fi

            # Fallback: lsof-based detection (works over SSH/headless)
            local lsof_match
            lsof_match=$(lsof -c zed -c code -c Cursor -c sublime_text 2>/dev/null \
                | grep -F "$wt_path" | head -1) || true
            if [[ -n "$lsof_match" ]]; then
                _last_editor_type=$(echo "$lsof_match" | awk '{print $1}')
                return 0
            fi
            ;;
    esac

    return 1
}

# Check if a Ralph loop is active for a worktree
# Args: $1 = worktree path
# Returns: 0 (true) if Ralph loop is running, 1 (false) otherwise
is_ralph_loop_active() {
    local wt_path="$1"
    local loop_state="$wt_path/.claude/loop-state.json"

    [[ ! -f "$loop_state" ]] && return 1

    local status
    status=$(jq -r '.status // ""' "$loop_state" 2>/dev/null) || return 1

    [[ "$status" == "running" ]] && return 0
    return 1
}

# Orphan grace period helpers
# Marker files: .wt-tools/orphan-detect/<pid> containing "<first_seen_timestamp>:<count>"
# Kill threshold: count >= 3 AND (now - first_seen) >= 15 seconds

orphan_marker_dir() {
    local wt_path="$1"
    local dir="$wt_path/.wt-tools/orphan-detect"
    mkdir -p "$dir" 2>/dev/null
    echo "$dir"
}

cleanup_stale_markers() {
    local marker_dir="$1"
    [[ ! -d "$marker_dir" ]] && return
    for marker in "$marker_dir"/*; do
        [[ ! -f "$marker" ]] && continue
        local mpid
        mpid=$(basename "$marker")
        if [[ "$mpid" =~ ^[0-9]+$ ]] && ! kill -0 "$mpid" 2>/dev/null; then
            rm -f "$marker"
        fi
    done
}

record_orphan_detection() {
    local marker_dir="$1"
    local pid="$2"
    local marker="$marker_dir/$pid"
    local now
    now=$(date +%s)
    if [[ -f "$marker" ]]; then
        local content
        content=$(cat "$marker" 2>/dev/null) || { echo "$now:1" > "$marker"; return; }
        local first_seen="${content%%:*}"
        local count="${content#*:}"
        ((count++))
        echo "$first_seen:$count" > "$marker"
    else
        echo "$now:1" > "$marker"
    fi
}

should_kill_orphan() {
    local marker_dir="$1"
    local pid="$2"
    local marker="$marker_dir/$pid"
    [[ ! -f "$marker" ]] && return 1
    local content
    content=$(cat "$marker" 2>/dev/null) || return 1
    local first_seen="${content%%:*}"
    local count="${content#*:}"
    local now
    now=$(date +%s)
    local elapsed=$((now - first_seen))
    if [[ "$count" -ge 3 ]] && [[ "$elapsed" -ge 15 ]]; then
        return 0
    fi
    return 1
}

reset_orphan_marker() {
    local marker_dir="$1"
    local pid="$2"
    rm -f "$marker_dir/$pid" 2>/dev/null
}

# Clean up orphan agents: kill "waiting" agents in worktrees with no editor and no Ralph loop
# Args: $1 = worktree path, $2 = agent_lines (status:pid entries), $3 = is_main_repo
# Outputs: filtered agent_lines with orphans removed
cleanup_orphan_agents() {
    local wt_path="$1"
    local agent_lines="$2"
    local is_main="${3:-false}"

    [[ -z "$agent_lines" ]] && return

    local marker_dir
    marker_dir=$(orphan_marker_dir "$wt_path")

    # Clean up stale markers for PIDs that no longer exist
    cleanup_stale_markers "$marker_dir"

    # If editor is open or Ralph loop is active, keep all agents and reset all markers
    if is_editor_open "$wt_path" "$is_main" || is_ralph_loop_active "$wt_path"; then
        while IFS=: read -r _s _p; do
            [[ -n "$_p" ]] && reset_orphan_marker "$marker_dir" "$_p"
        done <<< "$agent_lines"
        echo "$agent_lines"
        return
    fi

    # No editor, no Ralph loop — apply grace period to "waiting" agents
    local kept_lines=""
    while IFS=: read -r agent_status agent_pid; do
        [[ -z "$agent_status" ]] && continue

        if [[ "$agent_status" == "waiting" ]]; then
            # Safety check: never kill agents with an active TTY + shell (interactive session)
            local _tty
            _tty=$(ps -o tty= -p "$agent_pid" 2>/dev/null | tr -d ' ')
            if [[ -n "$_tty" ]] && [[ "$_tty" != "?" ]] && [[ "$_tty" != "??" ]]; then
                local _tty_procs
                _tty_procs=$(ps -t "$_tty" -o comm= 2>/dev/null)
                if echo "$_tty_procs" | grep -qE '^(zsh|bash|fish|sh|dash|-zsh|-bash|-fish|-sh|-dash|/usr/bin/login|login)$'; then
                    # Agent has active TTY with shell — interactive, do not kill
                    reset_orphan_marker "$marker_dir" "$agent_pid"
                    if [[ -n "$kept_lines" ]]; then
                        kept_lines+=$'\n'
                    fi
                    kept_lines+="${agent_status}:${agent_pid}"
                    continue
                fi
            fi

            # Record this orphan detection (grace period)
            record_orphan_detection "$marker_dir" "$agent_pid"

            # Only kill if threshold met: 3 consecutive detections AND 15s elapsed
            if should_kill_orphan "$marker_dir" "$agent_pid"; then
                kill "$agent_pid" 2>/dev/null || true
                echo "wt-status: killed orphan agent PID $agent_pid in $wt_path (grace period expired: 3x + 15s)" >&2
                rm -f "$marker_dir/$agent_pid" 2>/dev/null
                local skill_file="$wt_path/.wt-tools/agents/${agent_pid}.skill"
                rm -f "$skill_file" 2>/dev/null
            else
                # Keep agent alive during grace period (still shown as orphan in status)
                if [[ -n "$kept_lines" ]]; then
                    kept_lines+=$'\n'
                fi
                kept_lines+="${agent_status}:${agent_pid}"
            fi
        else
            # Keep running agents and reset their markers
            reset_orphan_marker "$marker_dir" "$agent_pid"
            if [[ -n "$kept_lines" ]]; then
                kept_lines+=$'\n'
            fi
            kept_lines+="${agent_status}:${agent_pid}"
        fi
    done <<< "$agent_lines"

    [[ -n "$kept_lines" ]] && echo "$kept_lines"
}

usage() {
    cat <<EOF
Usage: wt-status [options]

Display worktree and Claude agent status.

Options:
  -p, --project <name>    Show status for specific project
  -a, --all               Show all projects (default)
  -j, --json              Output as JSON
  -c, --compact           One-line summary for status bars
  -w, --watch             Continuous refresh (2s interval)
  -h, --help              Show this help

Examples:
  wt-status               # Show all worktrees with status
  wt-status --compact     # One-liner for status bar
  wt-status --json        # Machine-readable output
  wt-status --watch       # Auto-refresh every 2s
EOF
}

# Detect ALL Claude processes for a directory
# Returns: newline-separated list of "status:pid" entries, or empty if none found
detect_agents() {
    local wt_path="$1"

    # Find claude processes (use ps instead of pgrep — pgrep skips ancestors on macOS)
    local pids
    pids=$(ps -e -o pid=,comm= | awk '$2 == "claude" {print $1}') || true

    if [[ -z "$pids" ]]; then
        return
    fi

    # Collect PIDs that belong to this worktree
    local matching_pids=()
    while read -r pid; do
        [[ -z "$pid" ]] && continue

        # Get working directory of process
        local proc_cwd
        proc_cwd=$(get_proc_cwd "$pid") || continue
        [[ -z "$proc_cwd" ]] && continue

        # Check if process is in this worktree (exact match or subdir)
        if [[ "$proc_cwd" == "$wt_path" ]] || [[ "$proc_cwd" == "$wt_path/"* ]]; then
            matching_pids+=("$pid")
        fi
    done <<< "$pids"

    if [[ ${#matching_pids[@]} -eq 0 ]]; then
        return
    fi

    # Get session files sorted by mtime (freshest first)
    local proj_dir_name
    proj_dir_name=$(echo "$wt_path" | sed 's|/|-|g')
    local session_dir="$HOME/.claude/projects/$proj_dir_name"

    local session_files=()
    if [[ -d "$session_dir" ]]; then
        while IFS= read -r f; do
            [[ -n "$f" ]] && session_files+=("$f")
        done < <(ls -t "$session_dir"/*.jsonl 2>/dev/null)
    fi

    local now
    now=$(date +%s)
    local num_agents=${#matching_pids[@]}
    local num_sessions=${#session_files[@]}

    # Match PIDs to session files by mtime order (best-effort heuristic)
    # For each agent, determine status from the corresponding session file
    for i in "${!matching_pids[@]}"; do
        local pid="${matching_pids[$i]}"
        local status="waiting"

        if [[ $i -lt $num_sessions ]]; then
            local session_file="${session_files[$i]}"
            local mtime age
            mtime=$(get_file_mtime "$session_file")
            age=$((now - mtime))

            if [[ "$age" -lt 10 ]]; then
                status="running"
            fi
        fi

        # Check if agent is orphaned: no TTY means detached/abandoned process
        # Agents with a valid TTY are legitimate (terminal or IDE-launched)
        local tty
        tty=$(ps -o tty= -p "$pid" 2>/dev/null | tr -d ' ')
        if [[ -z "$tty" ]] || [[ "$tty" == "?" ]] || [[ "$tty" == "??" ]]; then
            # No TTY at all — orphan (terminal was closed, process survived)
            status="orphan"
        fi

        echo "$status:$pid"
    done
}

# Get last git activity time
get_last_activity() {
    local wt_path="$1"
    local last_commit
    last_commit=$(git -C "$wt_path" log -1 --format=%ct 2>/dev/null) || echo "0"
    echo "$last_commit"
}

# Check if Claude Code hooks are installed in a worktree
# Returns "true" if .claude/settings.json has both UserPromptSubmit and Stop hooks
check_hooks_installed() {
    local wt_path="$1"
    local settings_file="$wt_path/.claude/settings.json"

    if [[ ! -f "$settings_file" ]]; then
        echo "false"
        return
    fi

    if jq -e '.hooks.Stop' "$settings_file" &>/dev/null && jq -e '.hooks.UserPromptSubmit' "$settings_file" &>/dev/null; then
        echo "true"
    else
        echo "false"
    fi
}

# Get current skill for a specific agent PID
# Reads from .wt-tools/agents/<pid>.skill only (no legacy fallback)
# Returns "skill_name|freshness" if < 30 min, empty string otherwise
# freshness is "fresh" (just invoked) or "last" (subsequent prompts since)
get_agent_skill() {
    local wt_path="$1"
    local pid="$2"

    local skill_file="$wt_path/.wt-tools/agents/${pid}.skill"

    if [[ ! -f "$skill_file" ]]; then
        echo ""
        return
    fi

    local content
    content=$(cat "$skill_file" 2>/dev/null) || { echo ""; return; }

    # Parse: skill_name|timestamp|freshness
    local skill_name="${content%%|*}"
    local rest="${content#*|}"
    local timestamp="${rest%%|*}"
    local freshness="${rest#*|}"
    # Default freshness for old-format files without 3rd field
    [[ "$freshness" == "$timestamp" ]] && freshness="last"

    # Check if timestamp is valid and fresh (< 30 minutes = 1800 seconds)
    if [[ "$timestamp" =~ ^[0-9]+$ ]]; then
        local now age
        now=$(date +%s)
        age=$((now - timestamp))
        if [[ "$age" -lt 1800 ]]; then
            echo "${skill_name}|${freshness}"
            return
        fi
    fi

    echo ""
}

# Clean up stale PID skill files in .wt-tools/agents/
cleanup_stale_agents() {
    local wt_path="$1"
    local agents_dir="$wt_path/.wt-tools/agents"

    [[ ! -d "$agents_dir" ]] && return

    for skill_file in "$agents_dir"/*.skill; do
        [[ ! -f "$skill_file" ]] && continue
        local file_pid
        file_pid=$(basename "$skill_file" .skill)
        if [[ "$file_pid" =~ ^[0-9]+$ ]]; then
            if ! kill -0 "$file_pid" 2>/dev/null; then
                rm -f "$skill_file"
            fi
        fi
    done
}

# Collect status for one worktree
collect_worktree_status() {
    local project_name="$1"
    local wt_path="$2"
    local wt_name="$3"
    local branch="$4"
    local is_main_repo="${5:-false}"

    # Clean up stale agent skill files
    cleanup_stale_agents "$wt_path"

    # Detect all agents on this worktree
    local agent_lines
    agent_lines=$(detect_agents "$wt_path")

    # Check editor window presence (also sets _last_window_id, _last_editor_type)
    local editor_open="false"
    local window_id="null"
    local editor_type="null"
    if is_editor_open "$wt_path" "$is_main_repo"; then
        editor_open="true"
        [[ -n "$_last_window_id" ]] && window_id="\"$_last_window_id\""
        [[ -n "$_last_editor_type" ]] && editor_type="\"$_last_editor_type\""
    fi

    # Cleanup orphan agents (waiting agents with no editor and no Ralph loop)
    if [[ -n "$agent_lines" ]]; then
        agent_lines=$(cleanup_orphan_agents "$wt_path" "$agent_lines" "$is_main_repo")
    fi

    # Build agents JSON array
    local agents_json="["
    local first_agent=true
    if [[ -n "$agent_lines" ]]; then
        while IFS=: read -r agent_status agent_pid; do
            [[ -z "$agent_status" ]] && continue

            local skill_raw skill_name skill_fresh
            skill_raw=$(get_agent_skill "$wt_path" "$agent_pid")
            local skill_json="null"
            local skill_fresh_json="null"
            if [[ -n "$skill_raw" ]]; then
                skill_name="${skill_raw%%|*}"
                skill_fresh="${skill_raw#*|}"
                skill_json="\"$skill_name\""
                skill_fresh_json="\"$skill_fresh\""
            fi

            if ! $first_agent; then
                agents_json+=","
            fi
            first_agent=false

            agents_json+="{\"pid\":$agent_pid,\"status\":\"$agent_status\",\"skill\":$skill_json,\"skill_fresh\":$skill_fresh_json}"
        done <<< "$agent_lines"
    fi
    agents_json+="]"

    local last_activity
    last_activity=$(get_last_activity "$wt_path")

    # Check for uncommitted changes
    local has_changes="false"
    if git -C "$wt_path" status --porcelain 2>/dev/null | grep -q .; then
        has_changes="true"
    fi

    # Get git remote URL (use origin, normalized)
    local remote_url
    remote_url=$(git -C "$wt_path" remote get-url origin 2>/dev/null | sed 's/\.git$//' || echo "")

    # Check hook installation status
    local hooks_installed
    hooks_installed=$(check_hooks_installed "$wt_path")

    # Output as JSON object (will be collected into array)
    cat <<EOF
{
  "project": "$project_name",
  "change_id": "$wt_name",
  "path": "$wt_path",
  "branch": "$branch",
  "remote_url": "$remote_url",
  "is_main_repo": $is_main_repo,
  "hooks_installed": $hooks_installed,
  "editor_open": $editor_open,
  "window_id": $window_id,
  "editor_type": $editor_type,
  "agents": $agents_json,
  "git": {
    "last_commit": $last_activity,
    "uncommitted_changes": $has_changes
  }
}
EOF
}

# Collect all worktrees
collect_all_status() {
    local filter_project="$1"
    local worktrees_json="[]"
    local running=0
    local waiting=0
    local idle=0
    local total=0

    ensure_config

    local projects
    if [[ -n "$filter_project" ]]; then
        projects="$filter_project"
    else
        projects=$(jq -r '.projects | keys[]' "$CONFIG_FILE" 2>/dev/null)
    fi

    [[ -z "$projects" ]] && echo '{"worktrees":[],"summary":{"total":0,"running":0,"compacting":0,"waiting":0,"idle":0}}' && return

    local first=true
    echo '{"worktrees":['

    # Helper to emit one entry and count agent statuses
    emit_entry() {
        local _proj="$1" _path="$2" _name="$3" _branch="$4" _is_main="$5"

        if ! $first; then
            echo ","
        fi
        first=false

        collect_worktree_status "$_proj" "$_path" "$_name" "$_branch" "$_is_main"

        # Count agent statuses (per-agent, not per-worktree)
        local agent_lines
        agent_lines=$(detect_agents "$_path")
        if [[ -n "$agent_lines" ]]; then
            while IFS=: read -r _status _pid; do
                case "$_status" in
                    running) ((running++)) ;;
                    waiting) ((waiting++)) ;;
                esac
            done <<< "$agent_lines"
        else
            ((idle++))
        fi
        ((total++))
    }

    while IFS= read -r proj_name; do
        [[ -z "$proj_name" ]] && continue

        local proj_path
        proj_path=$(get_project_path "$proj_name")
        [[ ! -d "$proj_path" ]] && continue

        # Get worktrees
        local worktrees
        worktrees=$(git -C "$proj_path" worktree list --porcelain 2>/dev/null)
        [[ -z "$worktrees" ]] && continue

        # Emit main repo first
        local main_branch
        main_branch=$(get_main_branch "$proj_path")
        if [[ -n "$main_branch" ]]; then
            emit_entry "$proj_name" "$proj_path" "$main_branch" "$main_branch" "true"
        fi

        # Then emit worktrees (skip main repo and .wt-control)
        local current_path=""
        local current_branch=""

        while IFS= read -r line; do
            if [[ "$line" =~ ^worktree\ (.+)$ ]]; then
                current_path="${BASH_REMATCH[1]}"
            elif [[ "$line" =~ ^branch\ refs/heads/(.+)$ ]]; then
                current_branch="${BASH_REMATCH[1]}"
            elif [[ -z "$line" && -n "$current_path" ]]; then
                # Skip main repo and .wt-control worktree
                if [[ "$current_path" != "$proj_path" && "$current_path" != "$proj_path/.wt-control" ]]; then
                    # Extract change-id from branch (change/xxx -> xxx)
                    local change_id
                    if [[ "$current_branch" =~ ^change/(.+)$ ]]; then
                        change_id="${BASH_REMATCH[1]}"
                    else
                        change_id=$(basename "$current_path")
                    fi

                    emit_entry "$proj_name" "$current_path" "$change_id" "$current_branch" "false"
                fi
                current_path=""
                current_branch=""
            fi
        done <<< "$worktrees"

        # Handle last entry
        if [[ -n "$current_path" && "$current_path" != "$proj_path" && "$current_path" != "$proj_path/.wt-control" ]]; then
            local change_id
            if [[ "$current_branch" =~ ^change/(.+)$ ]]; then
                change_id="${BASH_REMATCH[1]}"
            else
                change_id=$(basename "$current_path")
            fi

            emit_entry "$proj_name" "$current_path" "$change_id" "$current_branch" "false"
        fi
    done <<< "$projects"

    echo '],"summary":{"total":'$total',"running":'$running',"compacting":0,"waiting":'$waiting',"idle":'$idle'}}'
}

# Format output for terminal
format_terminal() {
    local json="$1"

    local total running waiting idle
    total=$(echo "$json" | jq -r '.summary.total')
    running=$(echo "$json" | jq -r '.summary.running')
    waiting=$(echo "$json" | jq -r '.summary.waiting')
    idle=$(echo "$json" | jq -r '.summary.idle')

    if [[ "$total" == "0" ]]; then
        info "No active worktrees"
        return
    fi

    echo ""
    printf "  %-20s %-25s %-10s\n" "PROJECT" "CHANGE" "STATUS"
    echo "  ────────────────────────────────────────────────────────"

    echo "$json" | jq -r '.worktrees[] | . as $wt | (if (.agents | length) == 0 then [{"status":(if .editor_open then "idle (IDE)" else "idle" end),"skill":null}] else .agents end)[] | "\($wt.project)|\($wt.change_id)|\(.status)|\(.skill // "")"' | \
    while IFS='|' read -r project change status skill; do
        local icon color
        case "$status" in
            running)      icon="$ICON_RUNNING";    color="$GREEN" ;;
            waiting)      icon="$ICON_WAITING";    color="$YELLOW" ;;
            "idle (IDE)") icon="◇";                color="$BLUE" ;;
            idle)         icon="$ICON_IDLE";       color="$NC" ;;
            *)            icon="?";                color="$NC" ;;
        esac

        local status_str="$icon $status"
        [[ -n "$skill" ]] && status_str="$status_str ($skill)"

        printf "  %-20s %-25s ${color}%-10s${NC}\n" "$project" "$change" "$status_str"
    done

    echo ""
    local summary="  Summary: $total worktrees | ${GREEN}$running agents running${NC}"
    summary="$summary | ${YELLOW}$waiting waiting${NC} | $idle idle"
    echo "$summary"
    echo ""
}

# Format compact output
format_compact() {
    local json="$1"

    local total running waiting
    total=$(echo "$json" | jq -r '.summary.total')
    running=$(echo "$json" | jq -r '.summary.running')
    waiting=$(echo "$json" | jq -r '.summary.waiting')

    local output="wt: $total"
    [[ "$running" -gt 0 ]] && output="$output | $ICON_RUNNING $running"
    [[ "$waiting" -gt 0 ]] && output="$output | $ICON_WAITING $waiting"
    [[ "$running" -eq 0 && "$waiting" -eq 0 ]] && output="$output idle"

    echo "$output"
}

main() {
    local project=""
    local output_json=false
    local output_compact=false
    local watch_mode=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--project)
                project="$2"
                shift 2
                ;;
            -a|--all)
                project=""
                shift
                ;;
            -j|--json)
                output_json=true
                shift
                ;;
            -c|--compact)
                output_compact=true
                shift
                ;;
            -w|--watch)
                watch_mode=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done

    if $watch_mode; then
        # Watch mode - continuous refresh
        while true; do
            clear
            local json
            json=$(collect_all_status "$project")

            if $output_json; then
                echo "$json" | jq .
            elif $output_compact; then
                format_compact "$json"
            else
                echo "  Worktree Status (refreshing every 2s, Ctrl+C to exit)"
                format_terminal "$json"
            fi

            sleep 2
        done
    else
        local json
        json=$(collect_all_status "$project")

        if $output_json; then
            echo "$json" | jq .
        elif $output_compact; then
            format_compact "$json"
        else
            format_terminal "$json"
        fi
    fi
}

main "$@"
