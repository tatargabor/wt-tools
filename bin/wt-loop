#!/usr/bin/env bash
# wt-loop - Ralph-style autonomous loop for Claude Code
#
# Runs Claude Code in an iterative loop until a task is complete
# or max iterations reached.
#
# All subcommands (except "list") operate on the current worktree
# determined from CWD via git rev-parse --show-toplevel.

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/wt-common.sh"

# Find timeout command (macOS uses gtimeout from coreutils)
if command -v timeout &>/dev/null; then
    TIMEOUT_CMD="timeout"
elif command -v gtimeout &>/dev/null; then
    TIMEOUT_CMD="gtimeout"
else
    TIMEOUT_CMD=""
fi

# Default settings
DEFAULT_MAX_ITERATIONS=10
DEFAULT_DONE_CRITERIA="tasks"
DEFAULT_CAPACITY_LIMIT=80
DEFAULT_STALL_THRESHOLD=2  # Stop after N consecutive iterations with no commits

usage() {
    cat <<EOF
Usage: wt-loop <command> [options]

Run from within a worktree directory. The worktree is detected from CWD.

Commands:
  start "<task>" [opts]    Start a new loop
  stop                     Stop a running loop
  status                   Show loop status
  list                     List all active loops (global)
  history                  Show iteration history
  monitor [--interval N]   Monitor loop until complete
  run                      Internal: run the loop (called by terminal)

Start Options:
  --done <criteria>        Done detection: tasks|openspec|manual (default: tasks, auto-detects openspec)
  --max <n>                Max iterations (default: 10)
  --stall-threshold <n>    Stall after N commit-less iterations (default: 2)
  --iteration-timeout <n>  Per-iteration timeout in minutes (default: 45)
  --capacity-limit <pct>   Stop if capacity exceeds (default: 80%)
  --permission-mode <mode> Claude permission mode: auto-accept|allowedTools|plan (default: config)
  --label <text>           Label for this loop instance (shown in banner and terminal title)
  --force                  Force start even with incompatible permission mode (e.g. plan)

Monitor Options:
  --interval <seconds>     Polling interval (default: 30)

Examples:
  cd ~/project-wt-add-auth
  wt-loop start "Implement authentication per spec" --max 10
  wt-loop start "Build changes 01-12" --label "Run A (baseline)" --max 30
  wt-loop status
  wt-loop monitor --interval 15
  wt-loop stop
  wt-loop list              # global: shows loops across all worktrees
EOF
}

# Resolve worktree path from CWD using git
get_worktree_path_from_cwd() {
    local toplevel
    toplevel=$(git rev-parse --show-toplevel 2>/dev/null)
    if [[ -z "$toplevel" ]]; then
        error "Not inside a git worktree. Run from within a worktree directory."
        exit 1
    fi
    echo "$toplevel"
}

# Parse ISO 8601 date to epoch seconds (cross-platform)
# Works on both Linux (GNU date) and macOS (BSD date)
parse_date_to_epoch() {
    local date_str="$1"
    local epoch

    if [[ "$(uname)" == "Darwin" ]]; then
        # macOS: Convert ISO 8601 format to epoch
        # Remove timezone offset for parsing, use -j flag
        # ISO format: 2026-01-30T10:00:00-0800 or 2026-01-30T10:00:00+00:00
        local clean_date
        # Remove timezone suffix (anything after seconds)
        clean_date=$(echo "$date_str" | sed -E 's/[+-][0-9]{2}:?[0-9]{2}$//')
        # Try parsing, fallback to 0
        epoch=$(date -j -f "%Y-%m-%dT%H:%M:%S" "$clean_date" "+%s" 2>/dev/null || echo "0")
    else
        # Linux: GNU date supports -d with ISO 8601
        epoch=$(date -d "$date_str" +%s 2>/dev/null || echo "0")
    fi

    echo "$epoch"
}

# Get loop state file path for a worktree
get_loop_state_file() {
    local wt_path="$1"
    echo "$wt_path/.claude/loop-state.json"
}

get_loop_log_file() {
    local wt_path="$1"
    echo "$wt_path/.claude/ralph-loop.log"
}

# Get terminal PID file path
get_terminal_pid_file() {
    local wt_path="$1"
    echo "$wt_path/.claude/ralph-terminal.pid"
}

# Find tasks.md generically in a worktree (no openspec-specific paths)
find_tasks_file() {
    local wt_path="$1"

    # Prefer worktree root
    if [[ -f "$wt_path/tasks.md" ]]; then
        echo "$wt_path/tasks.md"
        return
    fi

    # Fallback: search in subdirectories (maxdepth 3), excluding archive/node_modules
    local found
    found=$(find "$wt_path" -maxdepth 3 -name "tasks.md" -type f \
        ! -path "*/archive/*" ! -path "*/node_modules/*" 2>/dev/null | head -1)
    if [[ -n "$found" ]]; then
        echo "$found"
        return
    fi

    # Not found
    return 1
}

# Initialize loop state
init_loop_state() {
    local wt_path="$1"
    local worktree_name="$2"
    local task="$3"
    local max_iter="$4"
    local done_criteria="$5"
    local capacity_limit="$6"
    local stall_threshold="${7:-$DEFAULT_STALL_THRESHOLD}"
    local iteration_timeout="${8:-45}"
    local label="${9:-}"

    local state_file
    state_file=$(get_loop_state_file "$wt_path")

    # Ensure .claude directory exists
    mkdir -p "$wt_path/.claude"

    # Create initial state
    cat > "$state_file" <<EOF
{
  "worktree_name": "$worktree_name",
  "task": $(echo "$task" | jq -Rs .),
  "done_criteria": "$done_criteria",
  "max_iterations": $max_iter,
  "current_iteration": 0,
  "status": "starting",
  "terminal_pid": null,
  "started_at": "$(date -Iseconds)",
  "iterations": [],
  "capacity_limit_pct": $capacity_limit,
  "stall_threshold": $stall_threshold,
  "iteration_timeout_min": $iteration_timeout,
  "total_tokens": 0,
  "label": $(if [[ -n "$label" ]]; then echo "\"$label\""; else echo "null"; fi)
}
EOF
}

# Update loop state
update_loop_state() {
    local state_file="$1"
    local field="$2"
    local value="$3"

    local tmp
    tmp=$(mktemp)
    jq ".$field = $value" "$state_file" > "$tmp" && mv "$tmp" "$state_file"
}

# Add iteration to state
add_iteration() {
    local state_file="$1"
    local iteration="$2"
    local started="$3"
    local ended="$4"
    local done_check="$5"
    local commits="$6"
    local tokens_used="${7:-0}"
    local timed_out="${8:-false}"
    local tokens_estimated="${9:-false}"

    local tmp
    tmp=$(mktemp)
    jq --argjson n "$iteration" \
       --arg started "$started" \
       --arg ended "$ended" \
       --argjson done "$done_check" \
       --argjson commits "$commits" \
       --argjson tokens "$tokens_used" \
       --argjson timed_out "$timed_out" \
       --argjson tokens_estimated "$tokens_estimated" \
       '.iterations += [{
         "n": $n,
         "started": $started,
         "ended": $ended,
         "done_check": $done,
         "commits": $commits,
         "tokens_used": $tokens,
         "timed_out": $timed_out,
         "tokens_estimated": $tokens_estimated
       }]' "$state_file" > "$tmp" && mv "$tmp" "$state_file"
}

# Get current token usage from wt-usage
get_current_tokens() {
    local since="${1:-}"
    local usage_json

    if [[ -n "$since" ]]; then
        usage_json=$("$SCRIPT_DIR/wt-usage" --since "$since" --format json 2>/dev/null || echo '{"total_tokens": 0}')
    else
        usage_json=$("$SCRIPT_DIR/wt-usage" --format json 2>/dev/null || echo '{"total_tokens": 0}')
    fi

    # Extract total_tokens, default to 0 if not a valid number
    local tokens
    tokens=$(echo "$usage_json" | jq -r '.total_tokens // 0' 2>/dev/null)
    # Ensure we return a number
    if [[ "$tokens" =~ ^[0-9]+$ ]]; then
        echo "$tokens"
    else
        echo "0"
    fi
}

# Estimate tokens from session file size growth
# Rough heuristic: ~4 tokens per byte of JSONL
estimate_tokens_from_files() {
    local wt_path="$1"
    local since_epoch="$2"

    local total_bytes=0
    local claude_dir="$HOME/.claude/projects"

    if [[ ! -d "$claude_dir" ]]; then
        echo "0"
        return
    fi

    # Find JSONL files modified since the given epoch
    while IFS= read -r -d '' jsonl_file; do
        local file_mtime
        file_mtime=$(stat -c %Y "$jsonl_file" 2>/dev/null || stat -f %m "$jsonl_file" 2>/dev/null || echo "0")
        if [[ "$file_mtime" -ge "$since_epoch" ]]; then
            local file_size
            file_size=$(stat -c %s "$jsonl_file" 2>/dev/null || stat -f %z "$jsonl_file" 2>/dev/null || echo "0")
            total_bytes=$((total_bytes + file_size))
        fi
    done < <(find "$claude_dir" -name "*.jsonl" -print0 2>/dev/null)

    # Rough estimate: 4 tokens per byte
    echo $((total_bytes / 4))
}

# Update terminal window title
update_terminal_title() {
    local title="$1"
    printf '\033]0;%s\007' "$title"
}

# Check if tasks.md is complete (all tasks checked)
check_tasks_done() {
    local wt_path="$1"

    # Find tasks.md generically
    local tasks_file
    tasks_file=$(find_tasks_file "$wt_path")

    if [[ -z "$tasks_file" ]]; then
        warn "No tasks.md found in $wt_path"
        return 1
    fi

    # Count incomplete tasks (- [ ] pattern)
    local count
    count=$(grep -cE '^\s*-\s*\[\s*\]' "$tasks_file" 2>/dev/null)
    count=${count//[^0-9]/}  # Strip any non-digit characters
    count=${count:-0}

    if [[ "$count" -eq 0 ]]; then
        return 0  # All done
    else
        return 1  # Not done
    fi
}

# Check done criteria
check_done() {
    local wt_path="$1"
    local criteria="$2"

    case "$criteria" in
        tasks)
            check_tasks_done "$wt_path"
            ;;
        openspec)
            # All OpenSpec changes complete when detect_next_change_action returns "done"
            local action
            action=$(detect_next_change_action "$wt_path")
            [[ "$action" == "done" ]]
            ;;
        manual)
            # Check if user marked done in state file
            local state_file
            state_file=$(get_loop_state_file "$wt_path")
            local manual_done
            manual_done=$(jq -r '.manual_done // false' "$state_file" 2>/dev/null)
            [[ "$manual_done" == "true" ]]
            ;;
        *)
            warn "Unknown done criteria: $criteria"
            return 1
            ;;
    esac
}

# Get commits since last iteration
get_new_commits() {
    local wt_path="$1"
    local since="${2:-}"

    cd "$wt_path" || return

    if [[ -n "$since" ]]; then
        git log --since="$since" --format='%h' 2>/dev/null | jq -R . | jq -s .
    else
        echo "[]"
    fi
}

# Detect the next OpenSpec change action needed.
# Returns: "ff:<change-name>" or "apply:<change-name>" or "done"
detect_next_change_action() {
    local wt_path="$1"

    # Get ordered change names from docs/benchmark/0*.md or openspec/changes/
    local change_order=()
    if ls "$wt_path"/docs/benchmark/0*.md &>/dev/null; then
        # Derive from numbered benchmark files: 01-product-catalog.md â†’ product-catalog
        for f in "$wt_path"/docs/benchmark/0*.md; do
            local name
            name=$(basename "$f" .md | sed 's/^[0-9]*-//')
            change_order+=("$name")
        done
    elif [[ -d "$wt_path/openspec/changes" ]]; then
        # Fallback: alphabetical order
        for d in "$wt_path"/openspec/changes/*/; do
            [[ -d "$d" ]] || continue
            local name
            name=$(basename "$d")
            [[ "$name" == "archive" ]] && continue
            change_order+=("$name")
        done
    fi

    if [[ ${#change_order[@]} -eq 0 ]]; then
        echo "none"
        return
    fi

    local change_idx=0
    for change in "${change_order[@]}"; do
        change_idx=$((change_idx + 1))
        local change_dir="$wt_path/openspec/changes/$change"
        local tasks_file="$change_dir/tasks.md"

        # Check 0: Does results file exist? (change fully done â€” test passed)
        local nn
        nn=$(printf "%02d" "$change_idx")
        if [[ -f "$wt_path/results/change-${nn}.json" ]]; then
            continue  # Skip â€” this change is verified complete
        fi

        # Check 1: Does tasks.md exist? (ff done)
        if [[ ! -f "$tasks_file" ]]; then
            echo "ff:$change"
            return
        fi

        # Check 2: Are all tasks checked? (apply done)
        local unchecked
        unchecked=$(grep -cE '^\s*-\s*\[\s*\]' "$tasks_file" 2>/dev/null)
        unchecked=${unchecked//[^0-9]/}  # Strip non-digit chars
        unchecked=${unchecked:-0}
        if [[ "$unchecked" -gt 0 ]]; then
            echo "apply:$change"
            return
        fi
    done

    echo "done"
}

# Build the prompt for Claude
build_prompt() {
    local task="$1"
    local iteration="$2"
    local max_iter="$3"
    local wt_path="$4"
    local done_criteria="$5"

    local prev_commits=""
    local state_file
    state_file=$(get_loop_state_file "$wt_path")

    if [[ -f "$state_file" ]]; then
        prev_commits=$(jq -r '[.iterations[].commits[]?] | join(", ")' "$state_file" 2>/dev/null || echo "")
    fi

    local prev_text=""
    if [[ -n "$prev_commits" ]]; then
        prev_text="Previous iterations made commits: $prev_commits"
    else
        prev_text="This is the first iteration."
    fi

    # Detect OpenSpec project and determine specific action
    local change_action=""
    local specific_task=""
    local openspec_instructions=""

    if [[ -d "$wt_path/openspec" ]]; then
        change_action=$(detect_next_change_action "$wt_path")

        case "$change_action" in
            ff:*)
                local change_name="${change_action#ff:}"
                specific_task="Create artifacts for the '$change_name' change"
                openspec_instructions="
# YOUR TASK (MANDATORY â€” do this and ONLY this)
Run: /opsx:ff $change_name
This will create design.md, specs, and tasks.md for the '$change_name' change.
Do NOT implement any code. Do NOT work on any other changes.
After /opsx:ff completes, commit the artifacts and stop.
"
                ;;
            apply:*)
                local change_name="${change_action#apply:}"
                specific_task="Implement the '$change_name' change"
                openspec_instructions="
# YOUR TASK (MANDATORY â€” do this and ONLY this)
Run: /opsx:apply $change_name
This will implement the tasks defined in tasks.md for the '$change_name' change.
Do NOT work on any other changes. Focus ONLY on '$change_name'.
After implementation, commit your changes and stop.
"
                ;;
            done)
                specific_task="All changes are complete"
                openspec_instructions="
# ALL CHANGES COMPLETE
All OpenSpec changes have been implemented. There is nothing left to do.
Do NOT write any files. Do NOT create any commits. Simply stop.
"
                ;;
            *)
                # No OpenSpec or no changes detected â€” use generic task
                specific_task="$task"
                ;;
        esac
    fi

    # Use specific task if detected, otherwise fall back to generic task
    local effective_task="${specific_task:-$task}"

    # Skip reflection when all changes are done â€” it creates dirty files
    # that prevent stall detection from firing as a safety net
    local reflection_section=""
    if [[ "$change_action" != "done" ]]; then
        reflection_section="
# Reflection (MANDATORY â€” last step before finishing)
Before you stop, write .claude/reflection.md with 3-5 bullet points:
- Errors you encountered and how you fixed them
- Non-obvious things you learned about this codebase
- Workarounds or gotchas the next iteration should know about
If nothing notable happened, write \"No notable issues.\" to the file."
    fi

    cat <<EOF
# Task
$effective_task

# Context
This is iteration $iteration of $max_iter in an autonomous Ralph loop.
Previous work is visible in the git history and current file state.

# Instructions
1. Read CLAUDE.md first â€” it contains the project workflow and specific instructions
2. Follow the workflow described in CLAUDE.md exactly
3. Do ONLY what is specified in YOUR TASK above â€” nothing more
4. If stuck on the same issue, try a different approach
$openspec_instructions
# Previous Work
$prev_text

# Important
- Do ONLY the task specified above â€” do NOT work on other changes
- CLAUDE.md is the authoritative source for your workflow â€” follow it
- Commit your changes before exiting
$reflection_section
EOF
}

# Run the actual loop (called in the spawned terminal)
cmd_run() {
    # Derive worktree from CWD
    local wt_path
    wt_path=$(get_worktree_path_from_cwd)
    local worktree_name
    worktree_name=$(basename "$wt_path")

    local state_file
    state_file=$(get_loop_state_file "$wt_path")

    if [[ ! -f "$state_file" ]]; then
        error "No loop state found. Use 'wt-loop start' first."
        exit 1
    fi

    # Read settings from state
    local max_iter done_criteria task capacity_limit stall_threshold iteration_timeout_min label permission_mode
    max_iter=$(jq -r '.max_iterations' "$state_file")
    done_criteria=$(jq -r '.done_criteria' "$state_file")
    task=$(jq -r '.task' "$state_file")
    capacity_limit=$(jq -r '.capacity_limit_pct' "$state_file")
    stall_threshold=$(jq -r '.stall_threshold // 2' "$state_file")
    iteration_timeout_min=$(jq -r '.iteration_timeout_min // 45' "$state_file")
    label=$(jq -r '.label // empty' "$state_file")
    permission_mode=$(jq -r '.permission_mode // "default"' "$state_file")

    # Signal trap variables for cleanup
    local current_iter_started=""
    local current_iter_num=0
    local cleanup_done=false

    cleanup_on_exit() {
        # Guard against double-trap (EXIT + SIGTERM)
        if [[ "$cleanup_done" == true ]]; then
            return
        fi
        cleanup_done=true

        echo ""
        echo "âš ï¸  Loop interrupted, recording state..."

        # Kill child processes (claude, tee, etc.) but not ourselves
        pkill -TERM -P $$ 2>/dev/null || true

        if [[ -n "$current_iter_started" && -f "$state_file" ]]; then
            local ended
            ended=$(date -Iseconds)
            local commits
            commits=$(get_new_commits "$wt_path" "$current_iter_started" 2>/dev/null || echo "[]")
            add_iteration "$state_file" "$current_iter_num" "$current_iter_started" "$ended" "false" "$commits" "0" "false"
        fi

        if [[ -f "$state_file" ]]; then
            update_loop_state "$state_file" "status" '"stopped"'
        fi
    }

    trap 'cleanup_on_exit' EXIT SIGTERM SIGINT SIGHUP

    # Update status
    update_loop_state "$state_file" "status" '"running"'
    update_loop_state "$state_file" "terminal_pid" "$$"

    # Save terminal PID
    echo "$$" > "$(get_terminal_pid_file "$wt_path")"

    cd "$wt_path" || exit 1

    # Gather context for banner
    local git_branch
    git_branch=$(git -C "$wt_path" branch --show-current 2>/dev/null || echo "unknown")
    local memory_status="inactive"
    if command -v wt-memory &>/dev/null && wt-memory health &>/dev/null; then
        memory_status="active"
    fi
    local title_suffix=""
    if [[ -n "$label" ]]; then
        title_suffix=" ($label)"
    fi

    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘  Ralph Loop: $worktree_name"
    if [[ -n "$label" ]]; then
    echo "â•‘  Label: $label"
    fi
    echo "â•‘  Path: $wt_path"
    echo "â•‘  Branch: $git_branch"
    echo "â•‘  Task: $task"
    echo "â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo "â•‘  Mode: $permission_mode | Max: $max_iter | Stall: $stall_threshold | Timeout: ${iteration_timeout_min}m"
    echo "â•‘  Memory: $memory_status"
    echo "â•‘  Started: $(date '+%Y-%m-%d %H:%M:%S')"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""

    local iteration=0
    local stall_count=0
    local repeated_msg_count=0
    local last_commit_msg=""
    local start_time
    start_time=$(date -Iseconds)

    while [[ $iteration -lt $max_iter ]]; do
        iteration=$((iteration + 1))

        # Update terminal title with progress
        update_terminal_title "Ralph: ${worktree_name}${title_suffix} [${iteration}/${max_iter}]"

        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "  ITERATION $iteration / $max_iter"
        echo "  $(date '+%H:%M:%S')"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""

        # Update state
        update_loop_state "$state_file" "current_iteration" "$iteration"

        local iter_start
        iter_start=$(date -Iseconds)
        current_iter_started="$iter_start"
        current_iter_num="$iteration"

        # Record tokens before iteration for tracking
        local tokens_before
        tokens_before=$(get_current_tokens "$start_time")

        # Build prompt
        local prompt
        prompt=$(build_prompt "$task" "$iteration" "$max_iter" "$wt_path" "$done_criteria")

        # Run Claude with retry logic and per-iteration timeout
        local timeout_seconds=$((iteration_timeout_min * 60))
        echo "Starting Claude Code... (timeout: ${iteration_timeout_min}m)"
        echo ""

        local claude_exit_code=0
        local retry_count=0
        local max_retries=2
        local iter_timed_out=false

        # Build Claude permission flags from state or config
        local perm_mode
        perm_mode=$(jq -r '.permission_mode // "auto-accept"' "$state_file" 2>/dev/null)
        local perm_flags
        perm_flags=$(get_claude_permission_flags "$perm_mode")

        while [[ $retry_count -lt $max_retries ]]; do
            # Pipe prompt via stdin to run in interactive mode (not -p print mode).
            # Interactive mode enables skills (/opsx:ff, /opsx:apply) and hooks.
            # - env -u CLAUDECODE: allow claude when invoked from a Claude session
            # - --foreground: keep child in foreground process group (prevents Tl stops)
            if [[ -n "$TIMEOUT_CMD" ]]; then
                echo "$prompt" | env -u CLAUDECODE $TIMEOUT_CMD --foreground --signal=TERM "$timeout_seconds" \
                    claude $perm_flags \
                       --verbose
            else
                echo "$prompt" | env -u CLAUDECODE claude $perm_flags \
                   --verbose
            fi
            claude_exit_code=$?

            if [[ $claude_exit_code -eq 124 ]]; then
                # Timeout exit code
                iter_timed_out=true
                echo ""
                echo "â±ï¸  Iteration timed out after ${iteration_timeout_min} minutes"
                echo "â±ï¸  Timeout: iteration $iteration exceeded ${iteration_timeout_min}m" >&2
                break  # Don't retry on timeout
            fi

            if [[ $claude_exit_code -eq 0 ]]; then
                break  # Success
            fi

            retry_count=$((retry_count + 1))
            if [[ $retry_count -lt $max_retries ]]; then
                echo ""
                echo "âš ï¸  Claude error (exit code: $claude_exit_code). Retrying in 30 seconds... (attempt $((retry_count + 1))/$max_retries)"
                sleep 30
            else
                echo ""
                echo "âš ï¸  Claude failed after $max_retries attempts. Continuing to next iteration..."
            fi
        done

        local iter_end
        iter_end=$(date -Iseconds)

        # Get new commits
        local new_commits
        new_commits=$(get_new_commits "$wt_path" "$iter_start")

        # Process reflection file (agent writes learnings here)
        local reflection_file="$wt_path/.claude/reflection.md"
        if [[ -f "$reflection_file" ]]; then
            local reflection_content
            reflection_content=$(cat "$reflection_file" 2>/dev/null)

            # Filter out noise: empty, too short, or generic/completion messages
            local should_save=true
            if [[ -z "$reflection_content" ]]; then
                should_save=false
            elif [[ "$reflection_content" == "No notable issues." ]]; then
                should_save=false
            elif echo "$reflection_content" | grep -qiE "^(all changes complete|no notable|no errors encountered|nothing to report)"; then
                should_save=false
            elif echo "$reflection_content" | grep -qiE "already (fully |)implemented|already existed|already had a proposal|already committed|confirm tests pass"; then
                should_save=false
            elif [[ ${#reflection_content} -lt 50 ]]; then
                should_save=false
            fi

            if $should_save; then
                if command -v wt-memory &>/dev/null && wt-memory health &>/dev/null 2>&1; then
                    # Extract change name from last commit for tagging
                    local change_tag=""
                    local last_msg
                    last_msg=$(cd "$wt_path" && git log -1 --format='%s' 2>/dev/null || echo "")
                    if [[ "$last_msg" == *:* ]]; then
                        local change_name="${last_msg%%:*}"
                        # Validate: change name should be kebab-case, not too long
                        if [[ "$change_name" =~ ^[a-z][a-z0-9-]+$ && ${#change_name} -lt 40 ]]; then
                            change_tag="change:$change_name,"
                        fi
                    fi

                    # Content dedup: check if similar memory already exists
                    local prefix="${reflection_content:0:80}"
                    local is_dupe=false
                    local existing
                    existing=$(wt-memory recall "$prefix" --limit 1 --mode semantic 2>/dev/null | \
                        python3 -c "
import sys, json
try:
    memories = json.load(sys.stdin)
    if memories and len(memories) > 0:
        existing = memories[0].get('content', '')[:80]
        new = sys.argv[1][:80]
        # Check if first 80 chars are >70% similar (simple overlap check)
        overlap = sum(1 for a, b in zip(existing, new) if a == b)
        threshold = int(min(len(existing), len(new)) * 0.7)
        print('dupe' if overlap > threshold and threshold > 30 else 'ok')
    else:
        print('ok')
except:
    print('ok')
" "$prefix" 2>/dev/null)
                    [[ "$existing" == "dupe" ]] && is_dupe=true

                    if ! $is_dupe; then
                        echo "$reflection_content" | wt-memory remember \
                            --type Learning \
                            --tags "${change_tag}source:agent,reflection" \
                            2>/dev/null && echo "ðŸ’­ Reflection saved to memory" || true
                    else
                        echo "ðŸ’­ Reflection skipped (duplicate)"
                    fi
                fi
            fi
            rm -f "$reflection_file"
        fi

        # Calculate tokens used this iteration
        local tokens_after tokens_used tokens_estimated=false
        tokens_after=$(get_current_tokens "$start_time")
        tokens_used=$((tokens_after - tokens_before))
        [[ $tokens_used -lt 0 ]] && tokens_used=0

        # Fallback: if tokens is 0 after claude ran, estimate from session file sizes
        if [[ $tokens_used -eq 0 && $claude_exit_code -ne 1 ]]; then
            echo "âš ï¸  Token tracking returned 0 after claude invocation" >&2
            local iter_start_epoch
            iter_start_epoch=$(parse_date_to_epoch "$iter_start")
            if [[ "$iter_start_epoch" -gt 0 ]]; then
                tokens_used=$(estimate_tokens_from_files "$wt_path" "$iter_start_epoch")
                if [[ $tokens_used -gt 0 ]]; then
                    tokens_estimated=true
                    tokens_after=$((tokens_before + tokens_used))
                    echo "ðŸ“Š Iteration tokens: ~$tokens_used (estimated from file sizes)"
                else
                    echo "ðŸ“Š Iteration tokens: 0"
                fi
            else
                echo "ðŸ“Š Iteration tokens: 0"
            fi
        else
            echo ""
            echo "ðŸ“Š Iteration tokens: $tokens_used (total: $tokens_after)"
        fi

        # Stall detection: no commits = no progress
        # Exception: ff iterations create artifacts without committing â€” check for new/modified files
        local has_artifact_progress=false
        if [[ "$new_commits" == "[]" ]] || [[ -z "$new_commits" ]]; then
            local dirty_count
            dirty_count=$(git status --porcelain 2>/dev/null | wc -l)
            if [[ "$dirty_count" -gt 0 ]]; then
                has_artifact_progress=true
            fi
        fi

        if { [[ "$new_commits" == "[]" ]] || [[ -z "$new_commits" ]]; } && ! $has_artifact_progress; then
            stall_count=$((stall_count + 1))
            echo "âš ï¸  No commits or new files this iteration (stall count: $stall_count/$stall_threshold)"

            # Check for stall condition
            if [[ $stall_count -ge $stall_threshold ]]; then
                echo ""
                echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
                echo "â•‘  ðŸ›‘ STALLED: No commits in $stall_count iteration(s)            â•‘"
                echo "â•‘  The loop appears to have nothing left to do.                   â•‘"
                echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                update_loop_state "$state_file" "status" '"stalled"'
                update_terminal_title "Ralph: ${worktree_name}${title_suffix} [stalled]"
                trap - EXIT SIGTERM SIGINT
                exit 0
            fi
        elif $has_artifact_progress; then
            stall_count=0  # Artifact creation counts as progress (ff iterations)
            echo "ðŸ“ No commits but new artifact files detected (ff iteration)"
        else
            stall_count=0  # Reset on progress
            echo "âœ… Commits this iteration: $(echo "$new_commits" | jq -r 'length') new"

            # Repeated commit message detection: same message N times = stall
            # Normalize: strip trailing iteration/attempt numbers for comparison
            local current_commit_msg
            current_commit_msg=$(git log -1 --format='%s' 2>/dev/null | sed -E 's/ (on |)iteration [0-9]+//; s/ \(attempt [0-9]+\)//' || echo "")
            if [[ -n "$current_commit_msg" && "$current_commit_msg" == "$last_commit_msg" ]]; then
                repeated_msg_count=$((repeated_msg_count + 1))
                echo "âš ï¸  Same commit message repeated ($repeated_msg_count/$stall_threshold): $current_commit_msg"
                if [[ $repeated_msg_count -ge $stall_threshold ]]; then
                    echo ""
                    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
                    echo "â•‘  ðŸ›‘ STALLED: Same commit message $repeated_msg_count times          â•‘"
                    echo "â•‘  \"${current_commit_msg:0:50}\"                                      â•‘"
                    echo "â•‘  The agent appears stuck in a loop.                             â•‘"
                    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    update_loop_state "$state_file" "status" '"stalled"'
                    update_terminal_title "Ralph: ${worktree_name}${title_suffix} [stalled]"
                    trap - EXIT SIGTERM SIGINT
                    exit 0
                fi
            else
                repeated_msg_count=0
                last_commit_msg="$current_commit_msg"
            fi
        fi

        # Check done
        local is_done=false
        if check_done "$wt_path" "$done_criteria"; then
            is_done=true
        fi

        # Add iteration to state with token tracking
        add_iteration "$state_file" "$iteration" "$iter_start" "$iter_end" "$is_done" "$new_commits" "$tokens_used" "$iter_timed_out" "$tokens_estimated"
        current_iter_started=""  # Clear so trap doesn't double-record

        # Update total tokens in state
        update_loop_state "$state_file" "total_tokens" "$tokens_after"

        if $is_done; then
            # Calculate total time
            local done_time done_epoch start_epoch_done total_secs_done total_hours_done total_mins_done
            done_time=$(date '+%Y-%m-%d %H:%M:%S')
            done_epoch=$(date +%s)
            start_epoch_done=$(parse_date_to_epoch "$start_time")
            [[ "$start_epoch_done" -eq 0 ]] && start_epoch_done="$done_epoch"
            total_secs_done=$((done_epoch - start_epoch_done))
            total_hours_done=$((total_secs_done / 3600))
            total_mins_done=$(((total_secs_done % 3600) / 60))

            echo ""
            echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
            echo "â•‘  âœ… TASK COMPLETE!                                              â•‘"
            echo "â•‘  Finished: $done_time                              â•‘"
            echo "â•‘  Iterations: $iteration | Runtime: ${total_hours_done}h ${total_mins_done}m                            â•‘"
            echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

            update_loop_state "$state_file" "status" '"done"'
            update_terminal_title "Ralph: ${worktree_name}${title_suffix} [done]"
            trap - EXIT SIGTERM SIGINT

            # Send notification
            notify-send "Ralph Loop Complete" "$worktree_name finished after $iteration iterations (${total_hours_done}h ${total_mins_done}m)" 2>/dev/null || true

            exit 0
        fi

        # Check if we should continue
        local current_status
        current_status=$(jq -r '.status' "$state_file" 2>/dev/null)
        if [[ "$current_status" == "stopped" ]]; then
            echo ""
            echo "Loop stopped by user."
            exit 0
        fi

        # Show iteration time
        local iter_end_epoch iter_start_epoch iter_duration
        iter_end_epoch=$(date +%s)
        iter_start_epoch=$(parse_date_to_epoch "$iter_start")
        [[ "$iter_start_epoch" -eq 0 ]] && iter_start_epoch="$iter_end_epoch"
        iter_duration=$((iter_end_epoch - iter_start_epoch))
        local iter_mins=$((iter_duration / 60))
        local iter_secs=$((iter_duration % 60))

        echo ""
        echo "Iteration $iteration completed in ${iter_mins}m ${iter_secs}s"
        echo "Not done yet. Continuing in 3 seconds..."
        echo "(Press Ctrl+C to stop)"
        sleep 3
    done

    # Max iterations reached - calculate total time
    local end_time end_epoch start_epoch total_secs total_hours total_mins
    end_time=$(date '+%Y-%m-%d %H:%M:%S')
    end_epoch=$(date +%s)
    start_epoch=$(parse_date_to_epoch "$start_time")
    [[ "$start_epoch" -eq 0 ]] && start_epoch="$end_epoch"
    total_secs=$((end_epoch - start_epoch))
    total_hours=$((total_secs / 3600))
    total_mins=$(((total_secs % 3600) / 60))

    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘  âš ï¸  MAX ITERATIONS REACHED                                     â•‘"
    echo "â•‘  Finished: $end_time                              â•‘"
    echo "â•‘  Total runtime: ${total_hours}h ${total_mins}m                                      â•‘"
    echo "â•‘  Task may not be complete. Review and resume if needed.        â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    update_loop_state "$state_file" "status" '"stuck"'
    update_terminal_title "Ralph: ${worktree_name}${title_suffix} [stuck]"
    trap - EXIT SIGTERM SIGINT

    # Send notification
    notify-send "Ralph Loop Stuck" "$worktree_name reached max iterations ($max_iter)" 2>/dev/null || true

    exit 1
}

# Start a new loop
cmd_start() {
    local task=""
    local max_iter="$DEFAULT_MAX_ITERATIONS"
    local done_criteria="$DEFAULT_DONE_CRITERIA"
    local capacity_limit="$DEFAULT_CAPACITY_LIMIT"
    local stall_threshold="$DEFAULT_STALL_THRESHOLD"
    local iteration_timeout=45
    local fullscreen=false
    local permission_mode_override=""
    local force_start=false
    local label=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --done)
                done_criteria="$2"
                shift 2
                ;;
            --max)
                max_iter="$2"
                shift 2
                ;;
            --stall-threshold)
                stall_threshold="$2"
                shift 2
                ;;
            --iteration-timeout)
                iteration_timeout="$2"
                shift 2
                ;;
            --capacity-limit)
                capacity_limit="$2"
                shift 2
                ;;
            --permission-mode)
                permission_mode_override="$2"
                shift 2
                ;;
            --force)
                force_start=true
                shift
                ;;
            --fullscreen)
                fullscreen=true
                shift
                ;;
            --label)
                label="$2"
                shift 2
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -*)
                error "Unknown option: $1"
                usage
                exit 1
                ;;
            *)
                if [[ -z "$task" ]]; then
                    task="$1"
                else
                    error "Unexpected argument: $1"
                    usage
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$task" ]]; then
        error "Task description required"
        usage
        exit 1
    fi

    # Derive worktree from CWD
    local wt_path
    wt_path=$(get_worktree_path_from_cwd)
    local worktree_name
    worktree_name=$(basename "$wt_path")

    # Auto-detect done criteria based on project structure
    if [[ "$done_criteria" == "tasks" ]]; then
        if [[ -d "$wt_path/openspec/changes" ]] && ls "$wt_path"/docs/benchmark/0*.md &>/dev/null 2>&1; then
            # OpenSpec project with ordered benchmark changes â€” use openspec done criteria
            done_criteria="openspec"
            info "Detected OpenSpec benchmark project, using 'openspec' done criteria"
        elif ! find_tasks_file "$wt_path" &>/dev/null; then
            warn "No tasks.md found, using manual done criteria"
            done_criteria="manual"
        fi
    fi

    # Check if loop already running
    local state_file
    state_file=$(get_loop_state_file "$wt_path")

    if [[ -f "$state_file" ]]; then
        local current_status
        current_status=$(jq -r '.status' "$state_file" 2>/dev/null)
        if [[ "$current_status" == "running" || "$current_status" == "starting" ]]; then
            # Check if process is actually alive
            local old_pid
            old_pid=$(jq -r '.terminal_pid // empty' "$state_file" 2>/dev/null)
            if [[ -n "$old_pid" ]] && kill -0 "$old_pid" 2>/dev/null; then
                error "Loop already running for $worktree_name (PID $old_pid)"
                echo "Use 'wt-loop stop' to stop it first."
                exit 1
            else
                warn "Previous loop (PID ${old_pid:-unknown}) is dead â€” overwriting stale state"
                update_loop_state "$state_file" "status" '"stopped"'
            fi
        fi
    fi

    # Check permission mode compatibility
    local effective_permission_mode
    if [[ -n "$permission_mode_override" ]]; then
        effective_permission_mode="$permission_mode_override"
    else
        effective_permission_mode=$(get_claude_permission_mode)
    fi

    if [[ "$effective_permission_mode" == "plan" ]]; then
        if [[ "$force_start" != true ]]; then
            error "Permission mode 'plan' is incompatible with Ralph loop (requires interactive approval)"
            echo "Use --force to override, or change permission mode:"
            echo "  wt-loop start --permission-mode auto-accept \"$task\""
            exit 1
        fi
        warn "Starting Ralph loop with 'plan' mode (--force). Claude will run without permission flags."
    fi

    # Initialize state
    info "Initializing loop state..."
    init_loop_state "$wt_path" "$worktree_name" "$task" "$max_iter" "$done_criteria" "$capacity_limit" "$stall_threshold" "$iteration_timeout" "$label"

    # Save permission mode in state
    local state_file_init
    state_file_init=$(get_loop_state_file "$wt_path")
    local tmp_pm
    tmp_pm=$(mktemp)
    jq --arg pm "$effective_permission_mode" '.permission_mode = $pm' "$state_file_init" > "$tmp_pm" && mv "$tmp_pm" "$state_file_init"

    # Spawn terminal with logging
    info "Spawning terminal for Ralph loop..."

    local terminal_title="Ralph: $worktree_name"
    if [[ -n "$label" ]]; then
        terminal_title="Ralph: $worktree_name ($label)"
    fi
    local log_file
    log_file=$(get_loop_log_file "$wt_path")

    # Clear previous log
    > "$log_file"

    # Save log path to state
    local state_file
    state_file=$(get_loop_state_file "$wt_path")
    jq --arg log "$log_file" '.log_file = $log' "$state_file" > "$state_file.tmp" && mv "$state_file.tmp" "$state_file"

    local fs_flag=""
    if [[ "$fullscreen" == true ]]; then
        fs_flag="--full-screen"
    fi

    # The run command: cd to worktree and run wt-loop run with tee for logging.
    # NOTE: We intentionally do NOT use `script` here. `script` creates a PTY that
    # makes Claude think it's in interactive mode, preventing it from exiting after
    # processing piped input. The terminal emulator already provides a TTY for the
    # parent shell; Claude's stdin comes from a pipe (echo | claude) which properly
    # closes on EOF without `script` interference.
    local run_cmd="cd \"$wt_path\" && \"$SCRIPT_DIR/wt-loop\" run 2>&1 | tee \"$log_file\""

    if [[ "$(uname)" == "Darwin" ]]; then
        # macOS: Use Terminal.app via osascript
        local temp_script="/tmp/ralph-loop-$(echo "$worktree_name" | tr '/' '-').sh"
        cat > "$temp_script" << SCRIPT
#!/bin/bash
cd "$wt_path"
"$SCRIPT_DIR/wt-loop" run 2>&1 | tee "$log_file"
SCRIPT
        chmod +x "$temp_script"
        # Launch in Terminal.app with auto-close
        osascript << APPLESCRIPT &
tell application "Terminal"
    set theTab to do script "exec /bin/bash $temp_script"
    set custom title of theTab to "$terminal_title"
    repeat
        delay 5
        try
            if not busy of theTab then exit repeat
        on error
            exit repeat
        end try
    end repeat
    delay 1
    try
        close (first window whose selected tab is theTab) saving no
    on error
        try
            repeat with w in (every window whose name contains "Ralph: $worktree_name")
                close w saving no
            end repeat
        end try
    end try
end tell
APPLESCRIPT
    elif command -v gnome-terminal &>/dev/null; then
        gnome-terminal $fs_flag --title="$terminal_title" -- bash -c "$run_cmd" &
    elif command -v xterm &>/dev/null; then
        [[ "$fullscreen" == true ]] && fs_flag="-fullscreen"
        xterm $fs_flag -title "$terminal_title" -e "bash -c '$run_cmd'" &
    elif command -v kitty &>/dev/null; then
        [[ "$fullscreen" == true ]] && fs_flag="--start-as=fullscreen"
        kitty $fs_flag --title "$terminal_title" bash -c "$run_cmd" &
    else
        error "No supported terminal found (gnome-terminal, xterm, kitty, Terminal.app)"
        exit 1
    fi

    sleep 1

    success "Ralph loop started!"
    echo ""
    echo "  Worktree: $worktree_name"
    echo "  Task: ${task:0:60}..."
    echo "  Max iterations: $max_iter"
    echo "  Done criteria: $done_criteria"
    echo "  Stall threshold: $stall_threshold"
    echo "  Iteration timeout: ${iteration_timeout}m"
    echo ""
    echo "Commands:"
    echo "  wt-loop status   - Check progress"
    echo "  wt-loop stop     - Stop the loop"
    echo "  wt-loop history  - View iteration history"
}

# Stop a running loop
cmd_stop() {
    local wt_path
    wt_path=$(get_worktree_path_from_cwd)
    local worktree_name
    worktree_name=$(basename "$wt_path")

    local state_file
    state_file=$(get_loop_state_file "$wt_path")

    if [[ ! -f "$state_file" ]]; then
        error "No loop found in: $worktree_name"
        exit 1
    fi

    # Update status to stopped
    update_loop_state "$state_file" "status" '"stopped"'

    # Try to kill terminal process
    local pid_file
    pid_file=$(get_terminal_pid_file "$wt_path")

    if [[ -f "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file")
        if kill -0 "$pid" 2>/dev/null; then
            info "Sending stop signal to loop process (PID: $pid)..."
            # Kill the entire process tree (loop script + claude + tee)
            pkill -TERM -P "$pid" 2>/dev/null || true
            kill "$pid" 2>/dev/null || true
            sleep 2
            # Force kill anything still alive
            pkill -9 -P "$pid" 2>/dev/null || true
            kill -9 "$pid" 2>/dev/null || true
        fi
        rm -f "$pid_file"
    fi

    # Close the Terminal window on macOS
    if [[ "$(uname)" == "Darwin" ]]; then
        sleep 1
        osascript <<EOF 2>/dev/null || true
tell application "Terminal"
    repeat with w in (every window whose name contains "Ralph: $worktree_name")
        close w saving no
    end repeat
end tell
EOF
    fi

    success "Loop stopped: $worktree_name"
}

# Show loop status
cmd_status() {
    local wt_path
    wt_path=$(get_worktree_path_from_cwd)
    local worktree_name
    worktree_name=$(basename "$wt_path")

    local state_file
    state_file=$(get_loop_state_file "$wt_path")

    if [[ ! -f "$state_file" ]]; then
        echo "No loop found in: $worktree_name"
        exit 0
    fi

    # Display status
    echo ""
    echo "Ralph Loop Status: $worktree_name"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

    local status iteration max_iter task started
    status=$(jq -r '.status' "$state_file")
    iteration=$(jq -r '.current_iteration' "$state_file")
    max_iter=$(jq -r '.max_iterations' "$state_file")
    task=$(jq -r '.task' "$state_file")
    started=$(jq -r '.started_at' "$state_file")

    # Detect orphan: state says "running" but process is dead
    if [[ "$status" == "running" ]]; then
        local loop_pid
        loop_pid=$(jq -r '.terminal_pid // empty' "$state_file")
        if [[ -n "$loop_pid" ]] && ! kill -0 "$loop_pid" 2>/dev/null; then
            status="stopped"
            update_loop_state "$state_file" "status" '"stopped"'
            warn "Loop process (PID $loop_pid) is dead â€” status corrected to stopped"
        fi
    fi

    local status_icon
    case "$status" in
        running) status_icon="ðŸ”„" ;;
        done) status_icon="âœ…" ;;
        stuck) status_icon="âš ï¸" ;;
        stalled) status_icon="â“" ;;
        stopped) status_icon="â¹ï¸" ;;
        *) status_icon="â“" ;;
    esac

    echo "  Status: $status_icon $status"
    echo "  Iteration: $iteration / $max_iter"
    echo "  Task: ${task:0:50}..."
    echo "  Started: $started"

    # Show token usage if available
    local total_tokens
    total_tokens=$(jq -r '.total_tokens // 0' "$state_file")
    if [[ "$total_tokens" -gt 0 ]]; then
        # Format with thousands separator
        local formatted_tokens
        formatted_tokens=$(printf "%'d" "$total_tokens")
        echo "  Tokens used: $formatted_tokens"
    fi

    # Show iteration summary
    local iter_count
    iter_count=$(jq '.iterations | length' "$state_file")
    if [[ "$iter_count" -gt 0 ]]; then
        echo ""
        echo "  Last iterations:"
        jq -r '.iterations[-3:][] | "    \(.n). \(.started | split("T")[1] | split("+")[0]) - done: \(.done_check) - tokens: \(.tokens_used // "N/A")"' "$state_file"
    fi

    echo ""
}

# List all active loops
cmd_list() {
    echo ""
    echo "Active Ralph Loops"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

    local found=0

    # Get all projects
    ensure_config
    local projects
    projects=$(jq -r '.projects | keys[]' "$CONFIG_FILE" 2>/dev/null)

    while IFS= read -r project_name; do
        [[ -z "$project_name" ]] && continue

        local project_path
        project_path=$(get_project_path "$project_name")
        [[ -z "$project_path" ]] && continue

        # Get all worktrees
        local worktrees
        worktrees=$(git -C "$project_path" worktree list --porcelain 2>/dev/null | grep '^worktree ' | cut -d' ' -f2-)

        while IFS= read -r wt_path; do
            [[ -z "$wt_path" ]] && continue
            [[ "$wt_path" == "$project_path" ]] && continue

            local state_file="$wt_path/.claude/loop-state.json"
            if [[ -f "$state_file" ]]; then
                local status wt_name iteration max_iter
                status=$(jq -r '.status' "$state_file" 2>/dev/null)
                wt_name=$(jq -r '.worktree_name // empty' "$state_file" 2>/dev/null)
                # Fallback for old state files that still have change_id
                if [[ -z "$wt_name" ]]; then
                    wt_name=$(jq -r '.change_id // empty' "$state_file" 2>/dev/null)
                fi
                if [[ -z "$wt_name" ]]; then
                    wt_name=$(basename "$wt_path")
                fi
                iteration=$(jq -r '.current_iteration' "$state_file" 2>/dev/null)
                max_iter=$(jq -r '.max_iterations' "$state_file" 2>/dev/null)

                local status_icon
                case "$status" in
                    running) status_icon="ðŸ”„" ;;
                    done) status_icon="âœ…" ;;
                    stuck) status_icon="âš ï¸" ;;
                    stopped) status_icon="â¹ï¸" ;;
                    *) status_icon="â“" ;;
                esac

                printf "  %-20s %s %-10s %s/%s\n" "$wt_name" "$status_icon" "$status" "$iteration" "$max_iter"
                found=1
            fi
        done <<< "$worktrees"
    done <<< "$projects"

    if [[ "$found" -eq 0 ]]; then
        echo "  No active loops found."
    fi

    echo ""
}

# Monitor loop until complete
cmd_monitor() {
    local interval=30

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --interval)
                interval="$2"
                shift 2
                ;;
            -*)
                error "Unknown option: $1"
                exit 1
                ;;
            *)
                shift
                ;;
        esac
    done

    local wt_path
    wt_path=$(get_worktree_path_from_cwd)
    local worktree_name
    worktree_name=$(basename "$wt_path")

    local state_file
    state_file=$(get_loop_state_file "$wt_path")

    echo ""
    echo "Monitoring Ralph Loop: $worktree_name"
    echo "Polling every ${interval}s (Ctrl+C to stop monitoring)"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""

    local last_iteration=0

    while true; do
        if [[ ! -f "$state_file" ]]; then
            echo "[$(date '+%H:%M:%S')] Waiting for loop to start..."
            sleep "$interval"
            continue
        fi

        local status iteration max_iter task started
        status=$(jq -r '.status' "$state_file" 2>/dev/null)
        iteration=$(jq -r '.current_iteration' "$state_file" 2>/dev/null)
        max_iter=$(jq -r '.max_iterations' "$state_file" 2>/dev/null)
        task=$(jq -r '.task' "$state_file" 2>/dev/null)
        started=$(jq -r '.started_at' "$state_file" 2>/dev/null)

        # Calculate elapsed time
        local started_epoch now_epoch elapsed_mins
        started_epoch=$(parse_date_to_epoch "$started")
        now_epoch=$(date +%s)
        elapsed_mins=$(( (now_epoch - started_epoch) / 60 ))

        # Report on iteration changes
        if [[ "$iteration" != "$last_iteration" ]]; then
            if [[ "$iteration" -gt 0 ]]; then
                echo "[$(date '+%H:%M:%S')] Iteration $iteration/$max_iter started (${elapsed_mins}m elapsed)"
            fi
            last_iteration="$iteration"
        fi

        # Check for final states
        case "$status" in
            done)
                echo ""
                echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                echo "âœ… LOOP COMPLETE!"
                echo "   Finished after $iteration iteration(s) in ${elapsed_mins} minutes"
                echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                exit 0
                ;;
            stuck)
                echo ""
                echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                echo "âš ï¸  LOOP STUCK"
                echo "   Max iterations ($max_iter) reached after ${elapsed_mins} minutes"
                echo "   Review work and resume or adjust approach"
                echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                exit 1
                ;;
            stopped)
                echo ""
                echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                echo "â¹ï¸  LOOP STOPPED"
                echo "   Stopped at iteration $iteration after ${elapsed_mins} minutes"
                echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                exit 0
                ;;
        esac

        sleep "$interval"
    done
}

# Show iteration history
cmd_history() {
    local wt_path
    wt_path=$(get_worktree_path_from_cwd)
    local worktree_name
    worktree_name=$(basename "$wt_path")

    local state_file
    state_file=$(get_loop_state_file "$wt_path")

    if [[ ! -f "$state_file" ]]; then
        error "No loop found in: $worktree_name"
        exit 1
    fi

    echo ""
    echo "Ralph Loop History: $worktree_name"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

    local task
    task=$(jq -r '.task' "$state_file")
    echo "Task: $task"
    echo ""

    echo "Iterations:"
    jq -r '.iterations[] | "  \(.n). Started: \(.started | split("T")[1] | split("+")[0]) | Ended: \(.ended | split("T")[1] | split("+")[0]) | Done: \(.done_check) | Commits: \(.commits | length) | Tokens: \(.tokens_used // "N/A")"' "$state_file"

    # Show total tokens
    local total_tokens
    total_tokens=$(jq -r '.total_tokens // 0' "$state_file")
    if [[ "$total_tokens" -gt 0 ]]; then
        local formatted_tokens
        formatted_tokens=$(printf "%'d" "$total_tokens")
        echo ""
        echo "Total tokens: $formatted_tokens"
    fi

    echo ""
}

# Main
main() {
    local cmd="${1:-}"
    shift || true

    case "$cmd" in
        start)
            cmd_start "$@"
            ;;
        stop)
            cmd_stop "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        list)
            cmd_list "$@"
            ;;
        history)
            cmd_history "$@"
            ;;
        monitor)
            cmd_monitor "$@"
            ;;
        run)
            cmd_run "$@"
            ;;
        -h|--help|"")
            usage
            exit 0
            ;;
        *)
            error "Unknown command: $cmd"
            usage
            exit 1
            ;;
    esac
}

main "$@"
