#!/usr/bin/env bash
# wt-new - Create a git worktree for a change

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/wt-common.sh"

usage() {
    cat <<EOF
Usage: wt-new <change-id> [options]

Create a git worktree for working on a spec change.
If a remote branch origin/change/<change-id> exists, it will be checked out.

Arguments:
  change-id               The change identifier (e.g., add-auth, fix-login)

Options:
  -p, --project <name>    Use specific project (default: auto-detect)
  -b, --branch <name>     Custom branch name (default: change/<change-id>)
  --skip-fetch            Skip git fetch (faster, but won't detect remote branches)
  --new                   Force create new branch even if remote exists
  -h, --help              Show this help

Examples:
  wt-new add-user-auth
  wt-new add-user-auth -p myproject
  wt-new fix-bug-123 --branch hotfix/bug-123
EOF
}

# Check if remote branch exists
has_remote_branch() {
    local project_path="$1"
    local branch_name="$2"
    git -C "$project_path" ls-remote --heads origin "$branch_name" 2>/dev/null | grep -q "$branch_name"
}

main() {
    local change_id=""
    local project_name=""
    local branch_name=""
    local skip_fetch=false
    local skip_open=false
    local force_new=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--project)
                project_name="$2"
                shift 2
                ;;
            -b|--branch)
                branch_name="$2"
                shift 2
                ;;
            --skip-fetch)
                skip_fetch=true
                shift
                ;;
            --skip-open)
                skip_open=true
                shift
                ;;
            --new)
                force_new=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -*)
                error "Unknown option: $1"
                usage
                exit 1
                ;;
            *)
                if [[ -z "$change_id" ]]; then
                    change_id="$1"
                else
                    error "Unexpected argument: $1"
                    usage
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$change_id" ]]; then
        error "Change ID required"
        usage
        exit 1
    fi

    # Resolve project
    local resolved_project
    resolved_project=$(resolve_project "$project_name") || exit 1

    local project_path
    project_path=$(get_project_path "$resolved_project")

    if [[ -z "$project_path" || ! -d "$project_path" ]]; then
        error "Project path not found: $project_path"
        exit 1
    fi

    # Check if a worktree with this name already exists (any naming pattern)
    local existing_wt
    existing_wt=$(find_existing_worktree "$project_path" "$change_id")

    if [[ -n "$existing_wt" ]]; then
        info "Worktree already exists: $existing_wt"
        echo "$existing_wt"
        exit 0
    fi

    # Determine worktree path for new worktree
    local wt_path
    wt_path=$(get_worktree_path "$project_path" "$change_id")

    # Determine branch name
    if [[ -z "$branch_name" ]]; then
        branch_name="change/$change_id"
    fi

    # Fetch latest from remote
    if ! $skip_fetch; then
        info "Fetching from remote..."
        timeout 10 git -C "$project_path" fetch origin 2>/dev/null || warn "Fetch timed out or failed, continuing..."
    fi

    # Check if branch exists locally
    local local_branch_exists=false
    if git -C "$project_path" show-ref --verify --quiet "refs/heads/$branch_name" 2>/dev/null; then
        local_branch_exists=true
    fi

    # Check if branch exists on remote
    local remote_branch_exists=false
    if ! $force_new && has_remote_branch "$project_path" "$branch_name"; then
        remote_branch_exists=true
    fi

    info "Creating worktree for '$change_id'..."
    echo "  Project: $resolved_project"
    echo "  Path: $wt_path"
    echo "  Branch: $branch_name"

    # Create worktree based on what exists
    if $local_branch_exists; then
        echo "  Source: local branch"
        git -C "$project_path" worktree add "$wt_path" "$branch_name"
    elif $remote_branch_exists; then
        echo "  Source: remote branch (checking out origin/$branch_name)"
        success "Continuing work from remote branch"
        git -C "$project_path" worktree add --track -b "$branch_name" "$wt_path" "origin/$branch_name"
    else
        echo "  Source: new branch"
        git -C "$project_path" worktree add -b "$branch_name" "$wt_path"
    fi

    if [[ $? -ne 0 ]]; then
        error "Failed to create worktree"
        exit 1
    fi

    # Deploy Claude Code hooks to the new worktree
    if command -v wt-deploy-hooks &>/dev/null; then
        "$SCRIPT_DIR/wt-deploy-hooks" --quiet "$wt_path" || warn "Hook deployment failed (non-fatal)"
    fi

    # Setup editor-specific configuration
    local editor_name
    editor_name=$(get_active_editor) || editor_name=""
    setup_editor_config "$wt_path" "$editor_name"

    # Create Claude context file
    setup_claude_context "$wt_path" "$change_id"

    success "Worktree created successfully"
    echo "$wt_path"

    # Automatically open in editor with Claude Code (unless --skip-open)
    if ! $skip_open; then
        "$SCRIPT_DIR/wt-work" "$change_id" -p "$resolved_project" --new-worktree
    fi
}

setup_editor_config() {
    local wt_path="$1"
    local editor_name="$2"

    case "$editor_name" in
        zed)
            setup_zed_tasks "$wt_path"
            ;;
        vscode|cursor)
            setup_vscode_tasks "$wt_path"
            ;;
        windsurf)
            # Windsurf uses VS Code-style tasks
            setup_vscode_tasks "$wt_path"
            ;;
        *)
            # No editor-specific setup for unknown editors
            ;;
    esac
}

setup_zed_tasks() {
    local wt_path="$1"
    local zed_dir="$wt_path/.zed"
    local tasks_file="$zed_dir/tasks.json"
    local keymap_file="$zed_dir/keymap.json"
    local global_tasks_file="$HOME/.config/zed/tasks.json"

    # Only create local tasks if no global "Claude Code" task exists (avoid duplicates)
    if ! grep -q '"Claude Code"' "$global_tasks_file" 2>/dev/null; then
        mkdir -p "$zed_dir"

        # Read permission mode from config
        local perm_mode
        perm_mode=$(get_claude_permission_mode 2>/dev/null || echo "auto-accept")
        local perm_args=""
        case "$perm_mode" in
            auto-accept)  perm_args='"--dangerously-skip-permissions"' ;;
            allowedTools) perm_args='"--allowedTools", "Edit,Write,Bash,Read,Glob,Grep,Task"' ;;
            plan)         perm_args="" ;;
        esac

        if [[ -n "$perm_args" ]]; then
            cat > "$tasks_file" << EOF
[
  {
    "label": "Claude Code",
    "command": "claude",
    "args": [$perm_args],
    "working_directory": "\$ZED_WORKTREE_ROOT",
    "use_new_terminal": true,
    "reveal": "always"
  }
]
EOF
        else
            cat > "$tasks_file" << 'EOF'
[
  {
    "label": "Claude Code",
    "command": "claude",
    "args": [],
    "working_directory": "$ZED_WORKTREE_ROOT",
    "use_new_terminal": true,
    "reveal": "always"
  }
]
EOF
        fi
        info "Created local Zed task: Claude Code"
    fi

    # Only create keymap if no global one exists (avoid duplicate triggers)
    if ! grep -q "ctrl-shift-l" ~/.config/zed/keymap.json 2>/dev/null; then
        mkdir -p "$zed_dir"
        cat > "$keymap_file" << 'EOF'
[
  {
    "bindings": {
      "ctrl-shift-l": ["task::Spawn", { "task_name": "Claude Code" }]
    }
  }
]
EOF
        info "Created local Zed keymap: Ctrl+Shift+L"
    fi
}

setup_vscode_tasks() {
    local wt_path="$1"
    local vscode_dir="$wt_path/.vscode"
    local tasks_file="$vscode_dir/tasks.json"

    # Setup global keybinding for Ctrl+Shift+L -> Claude Code panel
    setup_vscode_keybinding

    # Only create local tasks if doesn't exist
    if [[ -f "$tasks_file" ]]; then
        return 0
    fi

    mkdir -p "$vscode_dir"

    # Read permission mode from config
    local perm_mode
    perm_mode=$(get_claude_permission_mode 2>/dev/null || echo "auto-accept")
    local perm_args=""
    case "$perm_mode" in
        auto-accept)  perm_args='"--dangerously-skip-permissions"' ;;
        allowedTools) perm_args='"--allowedTools", "Edit,Write,Bash,Read,Glob,Grep,Task"' ;;
        plan)         perm_args="" ;;
    esac

    if [[ -n "$perm_args" ]]; then
        cat > "$tasks_file" << EOF
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Claude Code",
      "type": "shell",
      "command": "claude",
      "args": [$perm_args],
      "presentation": {
        "reveal": "always",
        "panel": "new"
      },
      "problemMatcher": []
    }
  ]
}
EOF
    else
        cat > "$tasks_file" << 'EOF'
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Claude Code",
      "type": "shell",
      "command": "claude",
      "args": [],
      "presentation": {
        "reveal": "always",
        "panel": "new"
      },
      "problemMatcher": []
    }
  ]
}
EOF
    fi
    info "Created VS Code task: Claude Code (run with Ctrl+Shift+P > Tasks: Run Task)"
}

setup_vscode_keybinding() {
    local keybindings_file="$HOME/.config/Code/User/keybindings.json"

    # Check if keybinding already exists
    if grep -q "claude-code.openInSidebar" "$keybindings_file" 2>/dev/null; then
        return 0
    fi

    # Create keybindings file if doesn't exist
    if [[ ! -f "$keybindings_file" ]]; then
        mkdir -p "$(dirname "$keybindings_file")"
        echo '[]' > "$keybindings_file"
    fi

    # Add keybinding using jq
    if command -v jq &>/dev/null; then
        local tmp_file
        tmp_file=$(mktemp)
        jq '. + [{"key": "ctrl+shift+l", "command": "claude-code.openInSidebar"}]' "$keybindings_file" > "$tmp_file" 2>/dev/null
        if [[ $? -eq 0 ]]; then
            mv "$tmp_file" "$keybindings_file"
            info "Added VS Code keybinding: Ctrl+Shift+L -> Claude Code"
        else
            rm -f "$tmp_file"
        fi
    fi
}

setup_claude_context() {
    local wt_path="$1"
    local change_id="$2"
    local claude_file="$wt_path/CLAUDE.md"

    # Don't overwrite if exists
    if [[ -f "$claude_file" ]]; then
        return 0
    fi

    cat > "$claude_file" << EOF
# Change: $change_id

This worktree was created for working on: \`$change_id\`

## Quick start

1. Describe what you want to build
2. I'll help you implement it
EOF

    info "Created CLAUDE.md with change context"
}

main "$@"
