#!/usr/bin/env bash
# wt-add - Add an existing git repository or worktree to wt-tools

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/wt-common.sh"

usage() {
    cat <<EOF
Usage: wt-add [path] [options]

Add an existing git repository or worktree to wt-tools.
If no path provided, uses current directory.

Options:
  --as <change-id>          Use this change-id (instead of auto-detect)
  -p, --project <name>      Associate with specific project
  -h, --help                Show this help

Examples:
  cd ../myproject-wt-feature && wt-add
  wt-add /path/to/existing/worktree
  wt-add /path/to/git/repo
  wt-add --as my-feature
  wt-add /path/to/repo --as custom-id -p myproject
EOF
}

# Check if directory is a valid git repository (worktree or regular repo)
is_git_repo() {
    local dir="${1:-.}"
    git -C "$dir" rev-parse --is-inside-work-tree &>/dev/null
}

# Check if directory is a worktree (as opposed to a regular repo)
is_worktree() {
    local dir="${1:-.}"
    [[ -f "$dir/.git" ]]
}

# Get main repo path from worktree
get_main_repo_from_worktree() {
    local wt_dir="${1:-.}"
    local git_file="$wt_dir/.git"

    if [[ -f "$git_file" ]]; then
        # Parse gitdir: line
        local gitdir
        gitdir=$(grep '^gitdir:' "$git_file" | sed 's/^gitdir: //')

        # gitdir points to .git/worktrees/<name>, we need .git parent
        # e.g., /path/to/main/.git/worktrees/feature -> /path/to/main
        local git_dir
        git_dir=$(dirname "$(dirname "$gitdir")")
        dirname "$git_dir"
    fi
}

# Get main repo path - works for both worktrees and regular repos
get_main_repo() {
    local dir="${1:-.}"
    if is_worktree "$dir"; then
        get_main_repo_from_worktree "$dir"
    else
        # Regular repo is its own main repo
        echo "$dir"
    fi
}

# Extract change-id from directory name or branch
derive_change_id() {
    local wt_path="${1:-.}"
    local wt_name
    wt_name=$(basename "$wt_path")

    # Pattern 1: *-wt-<change-id>
    if [[ "$wt_name" =~ -wt-(.+)$ ]]; then
        echo "${BASH_REMATCH[1]}"
        return 0
    fi

    # Pattern 2: *-<change-id> (repo-changeid format)
    # Get repo name to strip it
    local main_repo
    main_repo=$(get_main_repo_from_worktree "$wt_path")
    local repo_name
    repo_name=$(basename "$main_repo")

    if [[ "$wt_name" =~ ^${repo_name}-(.+)$ ]]; then
        echo "${BASH_REMATCH[1]}"
        return 0
    fi

    # Pattern 3: Get from branch name
    local branch
    branch=$(git -C "$wt_path" rev-parse --abbrev-ref HEAD 2>/dev/null)

    # change/<change-id>
    if [[ "$branch" =~ ^change/(.+)$ ]]; then
        echo "${BASH_REMATCH[1]}"
        return 0
    fi

    # feature/<name>
    if [[ "$branch" =~ ^feature/(.+)$ ]]; then
        echo "${BASH_REMATCH[1]}"
        return 0
    fi

    # Fallback: use directory name as-is
    echo "$wt_name"
}

# Register worktree in projects.json
register_worktree() {
    local project_name="$1"
    local change_id="$2"
    local wt_path="$3"
    local branch="$4"
    local is_wt="$5"  # "true" or "false"

    ensure_config

    # Check if already registered
    local existing
    existing=$(jq -r --arg proj "$project_name" --arg cid "$change_id" \
        '.projects[$proj].worktrees[$cid].path // empty' "$CONFIG_FILE" 2>/dev/null)

    if [[ -n "$existing" ]]; then
        if [[ "$existing" == "$wt_path" ]]; then
            warn "Already registered: $change_id"
            return 0
        else
            error "Change-id '$change_id' already registered with different path: $existing"
            return 1
        fi
    fi

    # Add to project
    local tmp_file
    tmp_file=$(mktemp)

    if jq --arg proj "$project_name" \
          --arg cid "$change_id" \
          --arg path "$wt_path" \
          --arg branch "$branch" \
          --argjson is_wt "$is_wt" \
        '.projects[$proj].worktrees[$cid] = {
            "path": $path,
            "branch": $branch,
            "added_manually": true,
            "is_worktree": $is_wt,
            "addedAt": (now | strftime("%Y-%m-%dT%H:%M:%SZ"))
        }' "$CONFIG_FILE" > "$tmp_file" 2>/dev/null; then
        mv "$tmp_file" "$CONFIG_FILE"
        return 0
    else
        rm -f "$tmp_file"
        return 1
    fi
}

main() {
    local wt_path=""
    local explicit_change_id=""
    local project_name=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --as)
                explicit_change_id="$2"
                shift 2
                ;;
            -p|--project)
                project_name="$2"
                shift 2
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -*)
                error "Unknown option: $1"
                usage
                exit 1
                ;;
            *)
                if [[ -z "$wt_path" ]]; then
                    wt_path="$1"
                else
                    error "Unexpected argument: $1"
                    usage
                    exit 1
                fi
                shift
                ;;
        esac
    done

    # Default to current directory
    if [[ -z "$wt_path" ]]; then
        wt_path="$(pwd)"
    fi

    # Resolve to absolute path
    wt_path=$(cd "$wt_path" && pwd)

    # Validate it's a git repository
    if ! is_git_repo "$wt_path"; then
        error "Not a git repository: $wt_path"
        echo ""
        echo "The selected directory is not a git repository."
        echo "Please select a directory that contains a git repo or worktree."
        exit 1
    fi

    # Determine if it's a worktree or regular repo
    local wt_flag="false"
    if is_worktree "$wt_path"; then
        wt_flag="true"
    fi

    # Get main repo
    local main_repo
    main_repo=$(get_main_repo "$wt_path")

    if [[ -z "$main_repo" ]]; then
        error "Could not determine main repository"
        exit 1
    fi

    # Resolve project (use main repo context)
    local resolved_project
    if [[ -n "$project_name" ]]; then
        resolved_project="$project_name"
        if [[ -z "$(get_project_path "$resolved_project")" ]]; then
            error "Project '$resolved_project' not found"
            exit 1
        fi
    else
        # Auto-detect from main repo
        # resolve_project may print info messages to stdout before the project name,
        # so we take only the last line (the actual project name)
        cd "$main_repo"
        resolved_project=$(resolve_project "" | tail -1) || exit 1
        cd - >/dev/null
    fi

    # Derive change-id
    local change_id
    if [[ -n "$explicit_change_id" ]]; then
        change_id="$explicit_change_id"
    else
        change_id=$(derive_change_id "$wt_path")
    fi

    # Get current branch
    local branch
    branch=$(git -C "$wt_path" rev-parse --abbrev-ref HEAD 2>/dev/null)

    local type_label="repository"
    if [[ "$wt_flag" == "true" ]]; then
        type_label="worktree"
    fi

    # If this is the main repo itself (not a worktree), just register the project.
    # The GUI automatically shows main repos as "â˜… master" rows.
    if [[ "$wt_flag" == "false" && "$wt_path" == "$main_repo" ]]; then
        info "Registering project '$resolved_project'..."
        echo "  Path:    $wt_path"
        echo "  Project: $resolved_project"
        echo "  Branch:  $branch"
        echo ""
        # Project was already auto-registered by resolve_project above.
        # No need to register as a worktree.
    else
        info "Adding $type_label to wt-tools..."
        echo "  Path:      $wt_path"
        echo "  Project:   $resolved_project"
        echo "  Change-ID: $change_id"
        echo "  Branch:    $branch"
        echo "  Type:      $type_label"
        echo ""

        # Register in projects.json
        if ! register_worktree "$resolved_project" "$change_id" "$wt_path" "$branch" "$wt_flag"; then
            error "Failed to register"
            exit 1
        fi
    fi

    # Deploy Claude Code hooks to project root
    if command -v wt-deploy-hooks &>/dev/null; then
        "$SCRIPT_DIR/wt-deploy-hooks" "$main_repo" || warn "Hook deployment failed (non-fatal)"
    fi

    success "Repository added successfully!"
    echo ""
    echo "It will now appear in Control Center."
    echo "You can use /wt skills and Ralph loop on it."
}

main "$@"
