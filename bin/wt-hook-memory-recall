#!/usr/bin/env bash
# wt-hook-memory-recall - Claude Code UserPromptSubmit hook for memory recall
#
# L2: Topic-based recall from prompt text. Fires on EVERY user prompt.
# No change-boundary detection, no debounce, no benchmark-specific code.
# Uses additionalContext JSON output for automatic injection.
#
# Designed to be referenced by name in .claude/settings.json:
#   "UserPromptSubmit": [{"matcher": "", "hooks": [{"type": "command", "command": "wt-hook-memory-recall", "timeout": 15}]}]

INPUT=$(cat)

# Only run if wt-memory is available and healthy
command -v wt-memory &>/dev/null || exit 0
wt-memory health &>/dev/null || exit 0

# Check if there are any memories to recall
MEMORY_COUNT=$(wt-memory status --json 2>/dev/null | python3 -c "import sys,json; print(json.load(sys.stdin).get('count',0))" 2>/dev/null)
[[ -z "$MEMORY_COUNT" || "$MEMORY_COUNT" == "0" ]] && exit 0

# Extract prompt text from hook input
PROMPT=$(echo "$INPUT" | python3 -c "import sys,json; print(json.load(sys.stdin).get('prompt',''))" 2>/dev/null)
[[ -z "$PROMPT" ]] && exit 0

# --- Build recall query ---
QUERY=""
CHANGE_NAME=""

# Check for opsx/openspec skill invocation â†’ extract change name
CHANGE_NAME=$(echo "$PROMPT" | python3 -c "
import sys, re
prompt = sys.stdin.read()
# Match opsx:xxx or openspec-xxx skill invocation followed by a change name
m = re.search(r'(?:opsx:\w+|openspec-[\w-]+)\s+(\S+)', prompt)
if m:
    print(m.group(1))
" 2>/dev/null)

if [[ -n "$CHANGE_NAME" ]]; then
    # Use change name + prompt text for targeted recall
    QUERY="$CHANGE_NAME $(echo "$PROMPT" | head -c 200)"
else
    # Use first 200 chars of prompt as recall query
    QUERY=$(echo "$PROMPT" | head -c 200)
fi

# --- Retrieve relevant memories ---
TMPFILE=$(mktemp)
trap "rm -f $TMPFILE" EXIT

# Try proactive first (context-aware with relevance scores)
if ! wt-memory proactive "$QUERY" --limit 5 2>/dev/null > "$TMPFILE"; then
    # Fallback to recall if proactive fails
    wt-memory recall "$QUERY" --limit 5 --mode hybrid 2>/dev/null > "$TMPFILE" || exit 0
fi

# If no memories or empty array, exit silently
CONTENT=$(cat "$TMPFILE")
[[ -z "$CONTENT" || "$CONTENT" == "[]" ]] && exit 0

# Format output: bulleted list with relevance filtering
FORMATTED=$(python3 -c "
import sys, json
try:
    memories = json.load(sys.stdin)
except:
    sys.exit(0)
if not memories:
    sys.exit(0)

# Filter out low-relevance results
filtered = []
for m in memories:
    score = m.get('relevance_score')
    if score is not None and score != 'N/A':
        try:
            if float(score) < 0.3:
                continue
        except (ValueError, TypeError):
            pass
    filtered.append(m)

if not filtered:
    sys.exit(0)

# Deduplicate by first 50 chars
seen = set()
for m in filtered:
    content = m.get('content', '').replace('\n', ' ')[:300]
    key = content[:50]
    if key in seen:
        continue
    seen.add(key)
    print(f'  - {content}')
" < "$TMPFILE" 2>/dev/null)

[[ -z "$FORMATTED" ]] && exit 0

# Build additionalContext text
CONTEXT_TEXT="=== PROJECT MEMORY ==="
if [[ -n "$CHANGE_NAME" ]]; then
    CONTEXT_TEXT="$CONTEXT_TEXT\nChange: $CHANGE_NAME"
fi
CONTEXT_TEXT="$CONTEXT_TEXT\nRelevant past experience:\n$FORMATTED\n=== END ==="

# Output as additionalContext JSON
python3 -c "
import json, sys
text = sys.argv[1]
output = {
    'hookSpecificOutput': {
        'hookEventName': 'UserPromptSubmit',
        'additionalContext': text
    }
}
print(json.dumps(output))
" "$CONTEXT_TEXT" 2>/dev/null

exit 0
